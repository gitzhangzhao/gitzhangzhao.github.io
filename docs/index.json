[{"categories":["BIOS"],"content":"申明: 本文严禁任何组织或个人在CSDN上进行转载,其他平台转载需经作者授权 本篇文章详细完整的讨论现代处理器 boot 的过程，主要面向对象为 Intel、AMD 的 X86 架构和大部分 ARM 处理器架构 前置概念 CPU 的引脚宝贵，只能用来连接高速设备（包括 Memory 和 PCIE 设备），原本通过北桥芯片来连接。但是目前，北桥芯片（用来连接内存和高速 PCIE）已经被集成进 CPU 中 低速的 IO（USB、SATA、eSPI 等）和其余的 PCIE 设备，不会直连 CPU 的，而是通过南桥芯片（PCH）来连接。PCH 是一块 IO 密集型芯片，BMC 芯片和 BIOS 芯片也是连接在 PCH 上的。然后 PCH 通过高速串行的总线 DMI 来和 CPU 连接，这样的目的是节约 CPU 的引脚（本质上是引脚复用） ","date":"2023-08-04","objectID":"/posts/bios/boot/:0:0","tags":["BIOS","UEFI","X86","Boot"],"title":"Boot 过程分析","uri":"/posts/bios/boot/"},{"categories":["BIOS"],"content":"After CPU 加电或 Reset 后，到 BIOS 执行之前的阶段 ","date":"2023-08-04","objectID":"/posts/bios/boot/:1:0","tags":["BIOS","UEFI","X86","Boot"],"title":"Boot 过程分析","uri":"/posts/bios/boot/"},{"categories":["BIOS"],"content":"1. CPU 自检 CPU 进行自身硬件初始化。初始化完成后，CPU 被设置为实地址模式，地址无分页。所有寄存器被初始化为特定的值， Cache、TLB（Translation Lookup Table）、BLB（Branch Target Buffer）这三个部件的内容被清空（Invalidate） ","date":"2023-08-04","objectID":"/posts/bios/boot/:1:1","tags":["BIOS","UEFI","X86","Boot"],"title":"Boot 过程分析","uri":"/posts/bios/boot/"},{"categories":["BIOS"],"content":"2. 设置 CPU 寄存器 寄存器 EIP（Instruction Pointer）、CS（Code Segment）被设置为 0x0000FFF0 和 0xFFFF0000。在实地址模式下（寄存器字长为 16 位），指令的物理地址是 CS « 4 + EIP。CPU 根据硬件设计，计算出第一条指令的地址：0xFFFF0000+0xFFF0 = 0xFFFFFFF0。随后，CPU 会从这个地址取指令并执行，需要在这个地址存放 BIOS 的代码 ","date":"2023-08-04","objectID":"/posts/bios/boot/:1:2","tags":["BIOS","UEFI","X86","Boot"],"title":"Boot 过程分析","uri":"/posts/bios/boot/"},{"categories":["BIOS"],"content":"3. Load BIOS 现在的问题是：在上电启动后，CPU 外围设备包括内存初始化还没有进行，没有内存可供使用，虽然有可以直接使用 Cache 替代内存的方法(Cache As RAM，CAR)，但总是没有直接用起来方便 但是，BIOS 代码是存放在一块 NOR Flash 中的，这块 Flash 在主板上通过 SPI 总线与 PCH 相连。NOR Flash 和我们用在 SSD 里面的 Flash 一个显著的不同就是它是字节寻址的，而不是块寻址。这就意味着它可以 XIP（eXecute in place），直接执行代码而不需要先 copy 到内存中 随后，CPU 去寻址 0xFFFFFFF0，PCH 的 SPI 总线默认 decode 该地址，从 Flash 芯片取指令；SPI 控制器响应 Flash 并返回内容给 DMI 总线（连接 PCH 和 CPU 的总线）；DMI 总线将指令给 CPU，开始解码执行。随后，通过这种方式一点一点 decode 运行，这个过程通常又称为 shadow 待续 ","date":"2023-08-04","objectID":"/posts/bios/boot/:1:3","tags":["BIOS","UEFI","X86","Boot"],"title":"Boot 过程分析","uri":"/posts/bios/boot/"},{"categories":["Embedded EVR"],"content":"申明: 本文严禁任何组织或个人在 CSDN 上进行转载,其他平台转载需经作者授权 之前的两篇文章介绍了 Petalinux 的安装和远程启动，本手册是系列的第三篇文章。本篇以 Embedded EVR 为例，详细介绍从 FPGA 代码的综合、布局布线、生成 bit 流，到使用 Petalinux 创建工程、配置、编译和部署的过程 前提条件：一台可以联网的服务器，并且已经安装好 Vivado 软件 ","date":"2023-07-01","objectID":"/posts/petalinux/petalinux_3/:0:0","tags":["Petalinux","ZYNQ"],"title":"Petalinux(三)：完全使用手册","uri":"/posts/petalinux/petalinux_3/"},{"categories":["Embedded EVR"],"content":"前言 博士期间，我主要利用 timing4(192.168.206.186) 服务器完成嵌入式 EVR 的研究，其中涉及到 FPGA 开发和嵌入式 Linux 系统。嵌入式系统的开发往往具有步骤复杂、过程繁琐的特点，Petalinux 这类自动化的软件工具大大简化了开发步骤 在 Docker 环境中使用 Petalinux 的原因，已经在系列第一篇文章中介绍了。本手册按照如下的步骤来介绍 Petalinux 的使用： 在 timing4 上生成嵌入式 EVR 的 bit 流文件 导出嵌入式 EVR 的硬件描述文件到 Petalinux 容器中 制作 Petalinux 镜像，以 2017.04 为例 使用 Petalinux 镜像创建容器 启动容器，创建 Petalinux 工程 修改或添加所需的设备树 根据硬件描述文件配置 Petalinux 配置 Linux 内核、U-Boot 和根文件系统 编译整个 Petalinux 工程 打包并整理内核、U-Boot 和根文件系统等镜像 使用镜像文件制作可启动的 TF 卡 容器使用中可能遇到的问题 在遇到不可解决的问题时，恢复 Docker 环境 ","date":"2023-07-01","objectID":"/posts/petalinux/petalinux_3/:1:0","tags":["Petalinux","ZYNQ"],"title":"Petalinux(三)：完全使用手册","uri":"/posts/petalinux/petalinux_3/"},{"categories":["Embedded EVR"],"content":"内容 ","date":"2023-07-01","objectID":"/posts/petalinux/petalinux_3/:2:0","tags":["Petalinux","ZYNQ"],"title":"Petalinux(三)：完全使用手册","uri":"/posts/petalinux/petalinux_3/"},{"categories":["Embedded EVR"],"content":"在 timing4 上生成嵌入式 EVR 的 bit 流文件 1. 登录到 timing4 服务器的图形界面 由于我们需要使用 Vivado 工具，所以需要登录图形界面。登录 timing4 服务器的图形化界面有两种方式： 使用 xrdp 协议 timing4 服务器安装了 xrdp 服务器，可以直接使用 windows 自带的远程桌面，登录 192.168.206.186.用户名使用自己的用户名，随后会提示输入密码 使用 rustdesk timing4 服务器上安装了 rustdesk Server，远程登录需要在 timing4 上安装运行 rustdesk Client，并且在自己的电脑上也安装好 rustdesk Client。具体的操作步骤请参考rustdesk 使用手册 上述两种方式各有优劣，方式 1 不需要安装额外客户端软件，方式 2 具有文件传输等更丰富便捷的功能 2. 启动 Vivado timing4 上的 Vivado 安装在目录/opt/Xilinx/Vivado/2017.4下，在这个目录下存在 setting64.sh 文件，其中配置了 Vivado 所需的一些环境变量以及 PATH 变量。建议在启动 Vivado 之前先执行source /opt/Xilinx/Vivado/2017.4/setting64.sh，也可以将这个命令添加进用户自己的.bashrc 或者.zshrc 中。.zshrc 中的环境变量可以参考/home/zhangzh/.zshrc 在终端中执行 vivado 命令，即可打开 Vivado 的图形化界面，此后的操作和 Windows 下一致： 3. 在 Vivado 中综合并布线嵌入式 EVR 嵌入式 EVR 的代码放在目录/home/zhangzh/Lab/vivado中，其中 test9 为 EVR 功能模块的代码，打包为自定义 IP，放在/home/zhangzh/Lab/vivado/test9/test9.ip_user_files目录下。test9_wizard 为自定义 IP 和 ZYNQ IP 的连线工程，其主要内容为 Block Design 和约束文件 如果没有修改代码的需要，则只需打开 test9_wizard 工程。在下图 1 的位置有生成 bit 流的按钮，将按顺序自动的运行综合，布局布线，最后产生 bit 流。一杯咖啡后，右上角显示wirte_bitstream Complete √即表示运行成功。布线后生成的 bit 流文件为/home/zhangzh/Lab/vivado/test9_wizard/test9_wizard.runs/impl_1/design_1_wrapper.bit。这个文件可以通过 JTAG 的方式直接烧写进 FPGA 中，但无法被 U-Boot 或 xdevcfg 烧写。还需要使用 bootgen 工具将其转换为 BIN 文件格式 4. 将硬件描述文件导出 为什么上一步已经得到了嵌入式 EVR 的 bit 流，还需要将硬件描述文件导出？这是因为硬件描述文件(.hdf)描述了完整的硬件信息，包括 FPGA 中使用的资源，这些信息正是 Petalinux 所需要的。需要注意的是，在 Vivado 的高版本中，hdf 文件已经被 xsa 文件替代 此时，FPGA 部分的工作就可以结束了，Petalinux 随后会根据硬件描述文件中提供的信息去配置工程，或者从 Vivado 工程中将 bit 流文件拷贝出来。在 Petalinux 最终生成的镜像文件中，同样也包含 bit 流文件 ","date":"2023-07-01","objectID":"/posts/petalinux/petalinux_3/:2:1","tags":["Petalinux","ZYNQ"],"title":"Petalinux(三)：完全使用手册","uri":"/posts/petalinux/petalinux_3/"},{"categories":["Embedded EVR"],"content":"制作 Petalinux 镜像 本节以 2017.04 版本为例，介绍如何在 timing4 上制作 Petalinux 镜像 创建 Dockerfile 文件 $ touch Dockerfile # 将以下内容写入 Dockerfile $ cat Dockerfile FROM ubuntu:16.04 RUN dpkg --add-architecture i386 RUN apt update \\ \u0026\u0026 apt install -y sudo libssl-dev flex bison chrpath socat autoconf libtool texinfo gcc-multilib libsdl1.2-dev libglib2.0-dev screen pax net-tools wget diffstat xterm gawk xvfb git make libncurses5-dev tftpd zlib1g libssl-dev gnupg tar unzip build-essential libtool-bin dialog cpio lsb-release zlib1g:i386 zlib1g-dev:i386 locales openjdk-8-jdk\" # build 镜像 $ docker build -t \u003cimage_name\u003e . 使用 docker images 命令来管理镜像。latest 为默认的镜像 tag ","date":"2023-07-01","objectID":"/posts/petalinux/petalinux_3/:2:2","tags":["Petalinux","ZYNQ"],"title":"Petalinux(三)：完全使用手册","uri":"/posts/petalinux/petalinux_3/"},{"categories":["Embedded EVR"],"content":"使用 Petalinux 镜像创建容器 获得镜像后，创建一个容器 # 使用镜像创建容器 $ docker run -it --name \u003cname\u003e -v \u003cdir:dir\u003e --user root \u003cimage_name\u003e /bin/bash # 使用 docker exec 命令启动 docker $ docker start name $ docker exec --user root -it \u003cname\u003e /bin/bash 进入容器后，在容器中继续执行安装 # 添加普通用户 $ adduser \u003cuser_name\u003e # 修改 /etc/sudoers 文件，添加 sudo 权限 # 用普通用户身份启动 docker $ docker exec --user \u003cuser_name\u003e -it \u003cname\u003e /bin/bash # 配置安装 locales， 使用 en_US.UTF-8 $ sudo dpkg-reconfigure locales # 设置 LANG 环境变量为 en_US.UTF-8 $ export LANG=\"en_US.UTF-8\" # 从共享目录中将 Petalinux 安装镜像 copy 到容器中 $ cp /mnt/petalinux/petalinux-v2017.4-final-installer.run ~ # 执行安装，lisence 输入 yes $ ./petalinux-v2017.4-final-installer.run dir # 安装完成后，source Petalinux 的安装目录中的 setting.sh # petalinux 开头的命令可以使用 $ petalinux-xxx 使用 docker ps -a 查看所有的容器 其中 petalinux_image 创建了 2 个容器，这两个容器是相关不关联的 注意：mzz2017/v2raya 镜像和 v2ray 容器是 timing4 服务器上的系统代理，用于访问外网。在浏览器中输入localhost:2017，管理代理的节点 ","date":"2023-07-01","objectID":"/posts/petalinux/petalinux_3/:2:3","tags":["Petalinux","ZYNQ"],"title":"Petalinux(三)：完全使用手册","uri":"/posts/petalinux/petalinux_3/"},{"categories":["Embedded EVR"],"content":"进入容器 此时 petalinux_20220621 容器已被成功创建 timing4 每次重启后，都需要运行docker start petalinux_20220621来启动容器。然后使用docker exec --user zhangzh -it petalinux_20220621 /bin/bash 命令来进入容器，--user后应为自己在容器中新建的用户。使用 exit 退出容器，此时容器没有关闭，下次仍然使用docker exec命令进入 需要注意的是：Petalinux 不支持除了 bash 以外的其他 shell 为了方便每次 source Petalinux 的安装目录中的 setting.sh，可以在自己的目录下的.bashrc文件中添加如下内容： $ tail -3 .bashrc export LANG=\"en_US.UTF-8\" cd $HOME source /xxx/settings.sh ","date":"2023-07-01","objectID":"/posts/petalinux/petalinux_3/:2:4","tags":["Petalinux","ZYNQ"],"title":"Petalinux(三)：完全使用手册","uri":"/posts/petalinux/petalinux_3/"},{"categories":["Embedded EVR"],"content":"创建 Petalinux 工程 进入 Petalinux 环境后，在普通用户下新建工程目录，然后使用petalinux-creat创建一个工程 $ petalinux-create --type \u003cproject_type\u003e --template zynq --name xxx 这里的 type 是创建的类型，有三种类型： project: petalinux 标准的工程 apps: linux 用户态应用程序，首先创建好 project，在到工程目录下使用petalinux-create -t apps --template install --name \u003capp-name\u003e --enable命令创建一个应用。--template可以选择 c、c++等模板。然后将应用程序代码拷贝到components/apps/\u003capp-name\u003e/src目录下，应用程序就可以被 Petalinux 编译并包含在根文件系统镜像中 modules: linux 内核态模块，用于在 Petalinux 环境下编写内核模块代码，编写的内核模块会被包含在根文件系统镜像中 在嵌入式 EVR 中，只需要创建 project，应用程序 EPICS 不通过 Petalinux 来编译 $ petalinux-create --type project --template zynq --name embedded_evr 此时，一个 Petalinux 工程就被创建完毕了。此时目录中只有config.project文件和project-spec目录 ","date":"2023-07-01","objectID":"/posts/petalinux/petalinux_3/:2:5","tags":["Petalinux","ZYNQ"],"title":"Petalinux(三)：完全使用手册","uri":"/posts/petalinux/petalinux_3/"},{"categories":["Embedded EVR"],"content":"添加设备树节点 在工程创建好以后，我们先不导入硬件配置，而要添加我们需要的代码。对于嵌入式 EVR，FPGA 部分相当于 Linux 的设备，所以需要添加一个挂在 AXI 总线上的节点 ZYNQ 本身带了一些设备树文件，Petalinux 会默认包含并编译这部分设备树文件。这些设备树文件用于 PS 部分一些标准的系统和 FPGA 部分的官方 IP。对于嵌入式 EVR 这种自定义的设备，就需要添加新的设备树。Petalinux 中添加设备树不需要修改 ZYNQ 的设备树代码，而是在目录/home/zhangzh/workspace/embedded_evr/project-spec/meta-user/recipes-bsp/device-tree/files下的system-user.dtsi文件中进行修改 # 添加如下内容 /include/ \"system-conf.dtsi\" / { amba_pl: amba_pl { #address-cells = \u003c1\u003e; #size-cells = \u003c1\u003e; compatible = \"simple-bus\"; ranges ; uio_dev@43c00000 { compatible = \"generic-uio\"; interrupt-controller; interrupt-parent = \u003c\u0026intc\u003e; interrupts = \u003c0x0 0x1d 0x1\u003e; reg = \u003c0x43c00000 0x10000\u003e; }; }; }; 为了让内核匹配设备驱动程序，还需要修改内核启动参数，将generic-uio标识符传入内核。通常有两种方式，可以在petalinux config后或者直接在上述文件中添加 bootargs 变量 # 添加内核启动参数 chosen { bootargs = \"console=ttyPS0,115200 earlyprintk uio_pdrv_genirq.of_id=generic-uio root=/dev/mmcblk0p2 rw rootwait\"; stdout-path = \"serial0:115200n8\"; }; 在设备树中添加的内核参数会被 U-Boot 程序读取，并设置 U-Boot 的 bootargs 变量。其中，对于 ZYNQ console 的值为 ttyPS0，波特率取决于串口芯片。root 挂载的文件系统必须是 linux 系统支持的根文件系统设备名。uio_pdrv_genirq.of_id表示了uio_pdrv_genirq这个驱动程序匹配字符串，需要和设备树中的一致 另一种方式是petalinux-config后，在 tui 界面中找到user set bootargs并添加 ","date":"2023-07-01","objectID":"/posts/petalinux/petalinux_3/:2:6","tags":["Petalinux","ZYNQ"],"title":"Petalinux(三)：完全使用手册","uri":"/posts/petalinux/petalinux_3/"},{"categories":["Embedded EVR"],"content":"根据硬件描述文件配置 Petalinux 随后，执行如下命令，Petalinux 会从 vivado 工程中导入硬件描述文件，并自动完成硬件的相关配置 petalinux-config --get-hw-description /mnt/vivado/test9_wizard/test9_wizard.sdk 上述命令有几个需要注意的点： 容器内部的/mnt 目录也就是外部系统的共享目录。创建容器时，需要将/home/zhangzh/Lab目录和容器的/mnt目录共享。如果共享了别的目录，应该修改这里的路径，使 Petalinux 找到 vivado 工程的目录 嵌入式事件定时系统的 hdf 文件导出到了 test9_wizard 路径下 路劲需要写到 vivado 工程根目录下的 sdk 文件夹 命令执行期间会弹出 tui 界面进行配置 对于嵌入式事件定时系统，需要在此时更改上一节中所描述的内核启动参数 ","date":"2023-07-01","objectID":"/posts/petalinux/petalinux_3/:2:7","tags":["Petalinux","ZYNQ"],"title":"Petalinux(三)：完全使用手册","uri":"/posts/petalinux/petalinux_3/"},{"categories":["Embedded EVR"],"content":"申明: 本文严禁任何组织或个人在 CSDN 上进行转载，其他平台转载需经作者授权 对于 Linux 远程启动是很普遍的，在 Petalinux 上配置远程启动很简单，并且 Petalinux 会自动配置 U-Boot 变量并增加内核启动参数 ","date":"2023-06-19","objectID":"/posts/petalinux/petalinux_2/:0:0","tags":["Petalinux","ZYNQ","NFS"],"title":"Petalinux(二)：远程启动","uri":"/posts/petalinux/petalinux_2/"},{"categories":["Embedded EVR"],"content":"1. 目标 内核文件通过 tftp 从 host 下载并启动，挂载的根文件系统为网络文件系统（nfs） 基本过程：BOOT.BIN 文件包括了硬件 bit 流、FSBL 和 U-Boot，这个文件放在板卡的 tf 卡或者 QSPI Flash 中，用于启动 Linux 内核。Linux 内核和设备树文件 image.ub 放在 host 上的 tftpboot 目录，U-Boot 通过 tftp 下载内核镜像到内存中，并启动内核。内核启动后，挂载 host 上的 nfs 文件系统作为根文件系统 ","date":"2023-06-19","objectID":"/posts/petalinux/petalinux_2/:0:1","tags":["Petalinux","ZYNQ","NFS"],"title":"Petalinux(二)：远程启动","uri":"/posts/petalinux/petalinux_2/"},{"categories":["Embedded EVR"],"content":"2. 组成：FSBL、U-Boot、kernel 和根文件系统 FSBL： 第二阶段引导文件，由 vivado 提供源码，用于在第一阶段引导代码（固定在芯片内的 rom 里）结束后，初始化一些 ZYNQ 常用的外设，由于是外部代码，可以根据需要自行修改 U-Boot： 第二阶段引导结束后将跳转执行 U-Boot，fsbl 没有远程拷贝的功能，所以 U-Boot 必须放置在板卡的可启动 ROM 内，主要为 TF 卡和 QSPI FLASH；U-Boot 具有板卡上大部分设备的驱动程序，可以配置网络，下载镜像并拷贝进内存中，最后跳转到内核的启动点 device tree： 设备树文件描述了硬件设备的信息，需要被 U-Boot 拷贝进内存并告诉内核地址，内核启动后读取设备树文件获取设备信息 Kernel： 内核镜像，有 uImage、zImage 等不同形式，具有不同的压缩方式与格式。U-Boot 支持各种形式的内核镜像，内核可以在本地部署也可以通过 tftp 或者 nfs 协议从 host 下载内核镜像，内核启动后初始化硬件并挂载根文件系统 根文件系统： 内核可以挂载本地 eMMC、TF 卡和远程 host 中的文件系统 ","date":"2023-06-19","objectID":"/posts/petalinux/petalinux_2/:0:2","tags":["Petalinux","ZYNQ","NFS"],"title":"Petalinux(二)：远程启动","uri":"/posts/petalinux/petalinux_2/"},{"categories":["Embedded EVR"],"content":"3. BOOT 所需文件的来源 FSBL： 由 VIVADO SDK 工具提供，使用 make 编译 U-Boot： 由官方发布源码，Xilinx 添加一些独有驱动，在 Github Xilinx 代码仓库维护，使用 make 编译 Kernel： Linux 内核源码，使用 make 编译 device tree： 由内核提供一部分，Xilinx 提供一部分，用户也可以自行添加，使用内核工具中的设备树专用编译器编译 根文件系统： 不同发行版针对不同体系结构有不同的根文件系统，目录结构固定，直接解压到被挂载的根目录，不需要编译 ","date":"2023-06-19","objectID":"/posts/petalinux/petalinux_2/:0:3","tags":["Petalinux","ZYNQ","NFS"],"title":"Petalinux(二)：远程启动","uri":"/posts/petalinux/petalinux_2/"},{"categories":["Embedded EVR"],"content":"各种文件的组织方式 由于最终都是将各种镜像拷贝进内存，被在每一阶段的最后跳转到下一阶段的执行点，所以理论上 BOOT 的过程可以将各种文件放置在不同的位置，或者相同位置下的不同文件 BOOT 文件的打包 FSBL、U-Boot、kernel、device tree 一起打包进 BOOT.BIN FSBL、U-Boot 打包进 BOOT.BIN，kernel 和 device tree 打包进 image.ub FSBL、U-Boot 打包进 BOOT.BIN，kernel 和 device tree 独立为 zImage 和 system.dtb 在 2 或 3 的基础上，BOOT.BIN 放在本地，kernel 和 device tree 放在远端，U-Boot 通过 tftp 协议从网络下载 kernel 和 device tree 在 2 或 3 的基础上，BOOT.BIN 放在本地，kernel 和 device tree 放在远端，U-Boot 通过 nfs 协议从网络下载 kernel 和 device tree 在 1、2、3、4、5 的基础上，BOOT.BIN 可以放在 tf 卡的第一分区或者 QSPI Flash 中 在 1、2、3、4、5、6 的基础上，根文件系统可以放在 tf 卡的非第一分区、eMMC 或通过 nfs 从网络挂载 ","date":"2023-06-19","objectID":"/posts/petalinux/petalinux_2/:0:4","tags":["Petalinux","ZYNQ","NFS"],"title":"Petalinux(二)：远程启动","uri":"/posts/petalinux/petalinux_2/"},{"categories":["Embedded EVR"],"content":"4. 使用手动编译生成可远程启动的镜像文件 使用手动编译 U-Boot 和 kernel 过程略 ","date":"2023-06-19","objectID":"/posts/petalinux/petalinux_2/:1:0","tags":["Petalinux","ZYNQ","NFS"],"title":"Petalinux(二)：远程启动","uri":"/posts/petalinux/petalinux_2/"},{"categories":["Embedded EVR"],"content":"配置 U-Boot 环境变量通过 tftp 启动 linux kernel 在 U-Boot 启动后，通过配置一些 U-Boot 环境变量来远程启动内核，这里假设内核和设备树文件放在 host 的/tftpboot 目录内 # 设置本机ip地址和host ip地址 zynq\u003e setenv ipaddr 192.168.206.187 zynq\u003e setenv serverip 192.168.206.187 # 将内核镜像zImage和设备树文件system.dtb通过tfpt下载进内存 # 将内核镜像下载到内存地址0x10000000 zynq\u003e tftpboot 10000000 zImage # 将设备树文件下载到内存地址 zynq\u003e tftpboot 10080000 system.dtb # 将地址传入bootz命令，启动zImage形式的内核 zynq\u003e bootz 10000000 - 10080000 由于手动编译设备树和内核文件分离，而挂载文件系统部分相似，后续挂载 nfs 见下一章节介绍 ","date":"2023-06-19","objectID":"/posts/petalinux/petalinux_2/:1:1","tags":["Petalinux","ZYNQ","NFS"],"title":"Petalinux(二)：远程启动","uri":"/posts/petalinux/petalinux_2/"},{"categories":["Embedded EVR"],"content":"5. 使用 petalinux 工具生成可远程启动镜像 在执行 petalinux-config 命令需要修改的部分 修改 U-Boot 配置 可以修改 netboot offset，即从远程下载镜像到内存中的地址偏移，远程 tftp server 的 IP 地址 修改镜像打包相关配置 build 整个系统 $ petalinux-build 将编译后的输出文件打包成适合部署的格式 # 一般 BOOT.BIN 包含 fsbl 文件、bitstream 和 U-Boot 文件 $ petalinux-package --boot --fsbl --fpga --u-boot --force 其余部分不需要修改，相关根文件系统挂载方式等等配置会生成相关内核参数，内核参数由 U-Boot 在启动时传递给内核 这里和之前手动编译生成启动镜像不同，没有下载设备树文件 system.dtb，原因是使用 petalinux 打包的内核镜像 image.ub 中是包含了设备树文件的。因为 image.ub 文件是通过 mkimage 命令制作的，是将内核镜像 zImage 和设备树 system.dtb 打包到一起 ","date":"2023-06-19","objectID":"/posts/petalinux/petalinux_2/:1:2","tags":["Petalinux","ZYNQ","NFS"],"title":"Petalinux(二)：远程启动","uri":"/posts/petalinux/petalinux_2/"},{"categories":["Embedded EVR"],"content":"6. 配置 U-Boot 启动 petalinux 编译的内核 基本步骤 基本步骤和手动编译启动内核一致，在远程 host 上需要具有 nfs 服务器，配置好 nfs 目录，并将根文件系统解压进该目录 在设置 IP 地址这一步，U-Boot 会先通过 DHCP 从 server 申请 IP 地址，如果 server 上有 DHCP 服务器，U-Boot 就会自动设置 ipaddr 这个环境变量，可以通过 printenv 打印出所有环境变量，serverip 这个环境变量是在 petalinux 配置阶段设置的 netboot 这个环境变量是 U-Boot 设置的，为 tfptboot ${netstart} ${kernel_img} \u0026\u0026 bootm, 其中 kernel_img 就是 image.ub 步骤： # 设置本机 ip 地址和 host ip 地址 zynq\u003e setenv ipaddr 192.168.138.2 zynq\u003e setenv servimagee通过 tfpt 下载进内存 # netboot 这个环境变量是 U-Boot 设置的，为 tfptboot ${netstart} ${kernel_img} \u0026\u0026 bootm, 其中 kernel_img 就是 image.ub zynq\u003e run netboot 配置默认启动命令 设置 U-Boot 默认命令，U-Boot 启动后会先配置网络，网络配置完成后就会进入倒计时，倒计时结束执行 bootcmd 中的命令，如果想自动 boot，只需要 zynq\u003e setenv bootcmd run netboot # 保存所有环境变量到 qspi zynq\u003e saveenv 配置内核参数环境变量 在设备树文件中有一个 chosen 字段，里面设置了内核参数变量 bootargs，U-Boot 中如果不手动配置这个变量，使用的是设备树文件中的内核参数，但是 U-Boot 中的 bootargs 环境变量具有最高优先级 ","date":"2023-06-19","objectID":"/posts/petalinux/petalinux_2/:1:3","tags":["Petalinux","ZYNQ","NFS"],"title":"Petalinux(二)：远程启动","uri":"/posts/petalinux/petalinux_2/"},{"categories":["Embedded EVR"],"content":"挂载 nfs 文件系统 决定根文件系统的方式主要是内核的启动参数，配置从 nfs 挂载，bootargs 应该被设置为 # petalinux会根据选项自动配置该变量 zynq\u003e setenv bootargs ‘console=ttyPS0,115200 root=/dev/nfs rw nfsroot=192.168.138.1:/home/zynq/linux/nfs/rootfs,tcp ip=dhcp’ 这个环境变量意义是，根文件系统使用 nfs 的方式以 rw 挂载，根文件系统目录在 192.168.138.1:/home/zynq/linux/nfs/rootfs，本机 ip 地址配置为 dhcp 方式从 server 获取 内核启动后会自动挂载 nfs 文件系统，如果挂载成功，内核就会启动完成 在挂载 nfs 时遇到问题：内核启动报错 VFS: Unable to mount root fs via NFS, trying floppy. VFS: Cannot open root device \"nfs\" or unknown-block(2,0): error -6 不能成功挂载的原因 防火墙问题 $ ufw disable 由于 nfs 版本不支持 目前新安装的 nfs 为 v4 版本，v2 已经废弃，但是很多比较老的内核不支持 v4，可能由于 nfs 解决方法 在内核配置中打开 nfs 文件系统对 nfs v4 的支持： \u003c*\u003e NFS client support for NFS version 4 在 nfs server 端的配置中打开对 nfs v2、nfs v3 和 nfs v4 的支持 $ echo 'RPCNFSDOPTS=\"--nfs-version 2,3,4 --debug --syslog\"' \u003e\u003e /etc/default/nfs-kernel-server $ systmectl restart nfs-server.service ","date":"2023-06-19","objectID":"/posts/petalinux/petalinux_2/:1:4","tags":["Petalinux","ZYNQ","NFS"],"title":"Petalinux(二)：远程启动","uri":"/posts/petalinux/petalinux_2/"},{"categories":["Embedded EVR"],"content":"申明: 本文严禁任何组织或个人在 CSDN 上进行转载，其他平台转载需经作者授权 课题需要可能要在 ZYNQ 上多次部署 Linux 并测试，普通的脚本安装方式太过繁琐，Xilinx 的 Petalinux 工具简化了很多流程。这里记录了一些主要步骤，由于实验室 Vivado 版本，所以选择的 Petalinux 版本也不是最新的 ","date":"2023-06-19","objectID":"/posts/petalinux/petalinux_1/:0:0","tags":["Petalinux","ZYNQ","NFS"],"title":"Petalinux(一)：安装","uri":"/posts/petalinux/petalinux_1/"},{"categories":["Embedded EVR"],"content":"why petalinux? 比分步编译更便捷的配置和编译源码 优势：petalinux 读取输入硬件配置，并根据硬件来自动的配置编译 u-boot，kernel，devicetree. 缺点：软件对系统版本，依赖版本要求比较高，配置相对麻烦。如果不按照规定好的顺序执行命令会遇上较多未知 BUG 目的：简化编译的过程，缩短时间并生成与硬件对应的正确的设备树文件 ","date":"2023-06-19","objectID":"/posts/petalinux/petalinux_1/:0:1","tags":["Petalinux","ZYNQ","NFS"],"title":"Petalinux(一)：安装","uri":"/posts/petalinux/petalinux_1/"},{"categories":["Embedded EVR"],"content":"petalinux 的安装 petalinux 对操作系统版本和依赖版本要求很高，只能在官方文档指定的发行版安装。这里以 petalinux 2017.04 为例 OS: ubuntu16.04(docker x86-64) Dependencies: sudo dpkg --add-architecture i386 sudo apt install libssl-dev flex bison chrpath socat autoconf libtool texinfo gcc-multilib libsdl1.2-dev libglib2.0-dev screen pax net-tools wget diffstat xterm gawk xvfb git make libncurse5-dev tftpd zlib1g libssl-dev gnupg tar unzip build-essential libtool-bin dialog cpio lsb-release zlib1g:i386 zlib1g-dev:i386 locales openjdk-8-jdk sudo dpkg-reconfigure locales export LANG=en_US.UTF-8 由于 Petalinux 依赖发行版版本，推荐采用 Docker 环境安装。请查看 Petalinux 2017.04 Docker 环境 ","date":"2023-06-19","objectID":"/posts/petalinux/petalinux_1/:0:2","tags":["Petalinux","ZYNQ","NFS"],"title":"Petalinux(一)：安装","uri":"/posts/petalinux/petalinux_1/"},{"categories":["Embedded EVR"],"content":"petalinux 的使用 创建一个 ZYNQ 的工程模板： petalinux-create --type project --template zynq --name petalinux 读取分析硬件所使用的开发版型号来配置： petalinux-config --get-hw-description /mnt/linux_base.sdk 配置内核和根文件系统： petalinux-config -c kernel petalinux-config -c rootfs 开始编译： petalinux-build 将编译好的工程打包输出： petalinux-package --boot --fsbl ./images/linux/zynq_fsbl.elf --fpga --u-boot --force 使用 qemu 虚拟化平台对产生的 BootLoader 和 linux 内核进行测试（可选） petalinux-boot --qemu --prebuilt 3 将输出的文件移动到开发板启动，或者使用 tftp 方式远程启动： image.ub: linux 的内核镜像，并且打包了设备树文件 plnx_arm-system.dtb, 在内存中运行的文件系统 ramdisk. # image.ub images { kernel@0 { description = \"Linux Kernel\"; data = /incbin/(\"zImage\"); type = \"kernel\"; arch = \"arm\"; os = \"linux\"; compression = \"none\"; load = \u003c0x8000\u003e; entry = \u003c0x8000\u003e; hash@1 { algo = \"sha1\"; }; }; fdt@0 { description = \"Flattened Device Tree blob\"; data = /incbin/(\"plnx_arm-system.dtb\"); type = \"flat_dt\"; arch = \"arm\"; compression = \"none\"; hash@1 { algo = \"sha1\"; }; }; ramdisk@0 { description = \"ramdisk\"; data = /incbin/(\"petalinux-user-image-plnx_arm.cpio.gz\"); type = \"ramdisk\"; arch = \"arm\"; os = \"linux\"; compression = \"none\"; hash@1 { algo = \"sha1\"; }; }; }; ","date":"2023-06-19","objectID":"/posts/petalinux/petalinux_1/:0:3","tags":["Petalinux","ZYNQ","NFS"],"title":"Petalinux(一)：安装","uri":"/posts/petalinux/petalinux_1/"},{"categories":["Embedded EVR"],"content":"petalinux 产生设备树的分析 使用 petalinux 的优势：自动分析硬件并产生设备树，也可以添加需要的部分并手动编译。 产生设备树的目录： $(project)/components/plnx_workspace/device-tree/device-tree-generation/ 设备树主要分两个部分： ARM CPU 相关的设备包括处理器内存，系统总线等等，在 zynq-7000.dtsi 中。（dtsi:设备树中描述 SOC 级的信息，一般不需要修改；dts: 设备树的源文件，修改设备树的主要对象；dtb: 由 dts 文件编译生成的二进制文件，由内核在启动时候读取并解析） petalinux 根据硬件的配置来生成 pl.dtsi 文件，文件内包括在根节点下的 FPGA 部分的设备树。 pl.dtsi 和 zynq-7000.dtsi 包含在 system-top.dts 内，手动添加的设备树也包含在内。 plnx_arm-system.dts 是处理了包含关系后的文件，编译生成 plnx_arm-system.dtb. pl.dtsi ---------| pcw.dtsi ---------|----\u003e system-top.dts ----\u003e plnx_arm-system.dts -----(dtc)----\u003e plnx_arm-system.dtb zynq-7000.dtsi ---| ","date":"2023-06-19","objectID":"/posts/petalinux/petalinux_1/:0:4","tags":["Petalinux","ZYNQ","NFS"],"title":"Petalinux(一)：安装","uri":"/posts/petalinux/petalinux_1/"},{"categories":["Embedded EVR"],"content":"实验：产生 GPIO 设备树文件，使用 Linux 内的 gpio 驱动程序，用文件 IO 方式驱动 led 系统描述：PS 和 PL 各有一个 led，通过 petalinux 产生一个完整 linux 系统，FPGA 端烧写一个 GPIO 控制器，输出 1 位信号到 R19 引脚，FPGA 的 R19 引脚连接了 pl 侧的 led 灯： set_property PACKAGE_PIN R19 [get_ports {gpio_out}] # R19引脚连接板上的led灯 set_property IOSTANDARD LVCMOS33 [get_ports {gpio_out}] linux 内核包含了 gpio 的驱动，可以根据设备树信息来自动检测硬件 $ cd /sys/class/gpio \u0026\u0026 ls export gpiochip906 gpiochip504 unexport # 访问/sys/class/gpio/目录，gpio906和gpio504分别是PS端和PL端的gpio控制器, export是内核提供的文件用于导出gpio的操作接口。 $ echo 906 \u003e export $ echo 504 \u003e export # 向export文件写入GPIO编号，就可以获得这个GPIO的操作接口。 $ ls export gpio906 gpiochip906 gpio504 gpiochip504 unexport # 新产生了gpio906和gpio504目录，目录中就是操作接口。 $ cd gpio906 \u0026\u0026 ls active_low direction power uevent device edge subsystem value # direction控制gpio的方向，value为gpio的输入输出值。 $ echo out \u003e direction $ echo 1 \u003e value # led灯灭 $ echo 0 \u003e value # led灯亮 # 通过一般的IO操作value这个文件就可以控制灯的亮灭。 产生的 GPIO 设备树部分(FPGA 侧): axi_gpio_0: gpio@41200000 { #gpio-cells = \u003c2\u003e; compatible = \"xlnx,xps-gpio-1.00.a\"; gpio-controller ; reg = \u003c0x41200000 0x10000\u003e; xlnx,all-inputs = \u003c0x0\u003e; xlnx,all-inputs-2 = \u003c0x0\u003e; xlnx,all-outputs = \u003c0x1\u003e; xlnx,all-outputs-2 = \u003c0x0\u003e; xlnx,dout-default = \u003c0x00000000\u003e; xlnx,dout-default-2 = \u003c0x00000000\u003e; xlnx,gpio-width = \u003c0x1\u003e; xlnx,gpio2-width = \u003c0x20\u003e; xlnx,interrupt-present = \u003c0x0\u003e; xlnx,is-dual = \u003c0x0\u003e; xlnx,tri-default = \u003c0xFFFFFFFF\u003e; xlnx,tri-default-2 = \u003c0xFFFFFFFF\u003e; }; ","date":"2023-06-19","objectID":"/posts/petalinux/petalinux_1/:0:5","tags":["Petalinux","ZYNQ","NFS"],"title":"Petalinux(一)：安装","uri":"/posts/petalinux/petalinux_1/"},{"categories":["Embedded EVR"],"content":"实验：直接将 FPGA 寄存器信号输出到 R19 引脚，通过 AXI-Lite 总线读写寄存器来控制 led 定义一个 32-bits 寄存器来接受总线信号，写入寄存器的值取一位输出到 led 灯 # 定义一个32位寄存器 reg [C_S_AXI_DATA_WIDTH-1:0] slv_reg0; # 将寄存器的第0位连接到输出信号 assign test_out = slv_reg0[0]; # 将总线模块打包，在test中调用AXI总线，添加一个输出信号test_out myip_v1_0_S00_AXI # ( .C_S_AXI_DATA_WIDTH(C_S00_AXI_DATA_WIDTH), .C_S_AXI_ADDR_WIDTH(C_S00_AXI_ADDR_WIDTH) ) myip_v1_0_S00_AXI_inst ( .S_AXI_ACLK(s00_axi_aclk), .S_AXI_ARESETN(s00_axi_aresetn), .S_AXI_AWADDR(s00_axi_awaddr), .S_AXI_AWPROT(s00_axi_awprot), .S_AXI_AWVALID(s00_axi_awvalid), .S_AXI_AWREADY(s00_axi_awready), .S_AXI_WDATA(s00_axi_wdata), .S_AXI_WSTRB(s00_axi_wstrb), .S_AXI_WVALID(s00_axi_wvalid), .S_AXI_WREADY(s00_axi_wready), .S_AXI_BRESP(s00_axi_bresp), .S_AXI_BVALID(s00_axi_bvalid), .S_AXI_BREADY(s00_axi_bready), .S_AXI_ARADDR(s00_axi_araddr), .S_AXI_ARPROT(s00_axi_arprot), .S_AXI_ARVALID(s00_axi_arvalid), .S_AXI_ARREADY(s00_axi_arready), .S_AXI_RDATA(s00_axi_rdata), .S_AXI_RRESP(s00_axi_rresp), .S_AXI_RVALID(s00_axi_rvalid), .S_AXI_RREADY(s00_axi_rready), .test_out(test_out) ); # 修改wrapper添加输出信号 output wire test_out # 绑定输出信号到led灯相连的引脚 set_property PACKAGE_PIN R19 [get_ports {test_out}] set_property IOSTANDARD LVCMOS33 [get_ports {test_out}] petalinux 根据系统硬件设计添加了 AXI-Lite 总线对应的设备树部分 # amba-axi总线的设备树部分 / { amba_pl: amba_pl { #address-cells = \u003c1\u003e; #size-cells = \u003c1\u003e; compatible = \"simple-bus\"; ranges ; myip_v1_0_0: myip_v1_0@43c00000 { # 寄存器的物理地址是0x43c00000 compatible = \"xlnx,myip-v1-0-1.0\"; reg = \u003c0x43c00000 0x10000\u003e; xlnx,s00-axi-addr-width = \u003c0x4\u003e; xlnx,s00-axi-data-width = \u003c0x20\u003e; }; }; }; 寄存器的物理地址是 0x43c00000，对这个地址的第一个字节的 0 位写值就可以控制 led 灯的亮灭 $ busybox devmem 0x43c00000 8 0x01 # 灯灭 $ busybox devmem 0x43c00000 8 0x00 # 灯亮 Q: 最小的寄存器组: 4 个(0x43c00000-0x43c0000f), 从 0x40000000-0x4fffffff 全部被映射到了最初的 16 个字节。 实际上被映射的物理内存区域有 1G，从地址 0x40000000-0x4fffffff ","date":"2023-06-19","objectID":"/posts/petalinux/petalinux_1/:0:6","tags":["Petalinux","ZYNQ","NFS"],"title":"Petalinux(一)：安装","uri":"/posts/petalinux/petalinux_1/"},{"categories":["Embedded EVR"],"content":"测试：从 Linux 端读写寄存器，寄存器连接一个宽度 16bit，深度 256 的 Block RAM，通过读写 3 个寄存器来实现对 Block RAM 的指定地址的读写。 由一个 TOP 模块，来例化了一个 AXI-Lite 总线接口，这个总线接口定义了 60 个寄存器并且引出。还有一个 BlockRAM 模块，将 AXI 总线定义的三个寄存器输入到 RAM 的控制接口里，然后通过对总线读写来控制 RAM。 AXI 总线模块： AXI_Lite axi_lite (.register00(AXI_Lite_register00), .register01(AXI_Lite_register01), .register02(AXI_Lite_register02), .register03(AXI_Lite_register03), .register04(AXI_Lite_register04), .register05(AXI_Lite_register05), .register06(AXI_Lite_register06), .register07(AXI_Lite_register07), .register08(AXI_Lite_register08), .register09(AXI_Lite_register09), .register10(AXI_Lite_register10), ...... 对 BlockRAM 的接口定义： bram_wrapper mappingRAM ( # 写地址：0x000-0x100(深度256) .BRAM_PORTA_0_addr(AXI_Lite_register01[7:0]), # 写时钟：FCLK_CLK0 .BRAM_PORTA_0_clk(s00_axi_aclk_0_1), # 写数据：16bit数据 .BRAM_PORTA_0_din(AXI_Lite_register02[15:0]), # PORTA使能 .BRAM_PORTA_0_en(1'b1), # PORTA写使能 .BRAM_PORTA_0_we(1'b1), # PORTB读地址 .BRAM_PORTB_0_addr(AXI_Lite_register03[7:0]), # PORTB读时钟 .BRAM_PORTB_0_clk(s00_axi_aclk_0_1), # PORTB读数据 .BRAM_PORTB_0_dout(w_ramout[15:0]), # PORTB读使能 .BRAM_PORTB_0_en(1'b1) ); ramout_0 -\u003e led(R19) # register ———————————————————— ————————————- | register01[7:0] | ————\u003e 写地址，输入到PORTA addr ——————\u003e | | ———————————————————— | register02[15:0] | ————\u003e 写数据，输入到PORTA din ——————\u003e | 256 x 16 | ———————————————————— | register03[7:0] | ————\u003e 读地址，输入到PORTB addr ——————\u003e | | ———————————————————— ————————————- | ramout[0] —————————————— | led \u003c———————————————————| ramout[15:0] |————————— —————————————— 测试过程: # 初始状态：ram内全部清零，ramout[0] 输出为0，\"led灯亮\" # 给RAM的写地址端口写入0x43c00004 $ busybox devmem 0x43c00004 8 0x55 # 给RAM的写数据端口写入16位数据0x0001 $ busybox devmem 0x43c00008 16 0x0001 此时RAM的0x55地址写入了数据 0000 0000 0000 0001 # 给0x43c0000c地址写入0x55，表示给RAM的读地址端口写0x55 $ busybox devmem 0x43c0000c 8 0x55 此时ramout的第0位由0变成了1，\"led灯灭\" # 把0x55的数据重新写为0 $ busybox devmem 0x43c00008 16 0x0000 \"led灯亮\" # 或者改变读地址的值 $ busybox devmem 0x43c0000c 8 0x56 \"led灯亮\" 上述实验证明数据写入 RAM 成功 ","date":"2023-06-19","objectID":"/posts/petalinux/petalinux_1/:0:7","tags":["Petalinux","ZYNQ","NFS"],"title":"Petalinux(一)：安装","uri":"/posts/petalinux/petalinux_1/"},{"categories":["Linux"],"content":"申明: 本文严禁任何组织或个人在 CSDN 上进行转载，其他平台转载需经作者授权 ","date":"2023-06-18","objectID":"/posts/gentoo/gentoo%E5%AE%89%E8%A3%85%E5%B0%8F%E8%AE%B0/:0:0","tags":["Linux","Gentoo"],"title":"Gentoo 安装小记","uri":"/posts/gentoo/gentoo%E5%AE%89%E8%A3%85%E5%B0%8F%E8%AE%B0/"},{"categories":["Linux"],"content":"前言 安装 Gentoo 并不复杂，很多人混淆了复杂和耗时。在安装的过程中，大部分的时间都在做别的事情。同时，Gentoo 的安装步骤是清晰的，Handbook 和各路神仙的总结实际上已经很全面了。因此，没有必要再做重复的劳动，一些个性化的关键点记录就足够了。 为了使系统保持 Suckless，尽量避免用不到的功能，我还是继续沿用裸 wm 的方式。简而言之：gentoo + openrc + i3wm + polybar + nvim。我的目标是尽量在一天内完成系统的整体安装，再用一周时间进行小修小补。而在流程化的步骤下，一天内的实际安装时间在 1 小时左右，而其余时间都在做其他事情。 此外，对于小新 Pro 这种散热垃圾的 Laptop，一个带风扇的散热架是必要的。否则，emerge -e @world 是真的会卡死（哭）。 ","date":"2023-06-18","objectID":"/posts/gentoo/gentoo%E5%AE%89%E8%A3%85%E5%B0%8F%E8%AE%B0/:0:1","tags":["Linux","Gentoo"],"title":"Gentoo 安装小记","uri":"/posts/gentoo/gentoo%E5%AE%89%E8%A3%85%E5%B0%8F%E8%AE%B0/"},{"categories":["Linux"],"content":"安装步骤 Gentoo 的安装大体上是规范的，但是针对不同用户的需求和理念，也有不一样的方式。或多或少的，存在一些坑 我在安装过程主要参考的几个链接： 官方 Handbook，这是最权威的手册，当问题不确定时，以 Handbook 为准 Handbook 一篇较为详细的安装笔记，属于经验丰富的老玩家心得了，很有参考价值 Gentoo 安装流程分享(step by step)，第一篇之基本系统的安装 OriPoin’s blog，详细介绍了 Gentoo 的优化方式，但是没必要采用 O3，会带来很多未知问题 Emerge your world the lean way Optimize Your system the stupid way bitbili’s blog，非常非常详细的介绍了 Gentoo 的安装和使用 Gentoo Linux 安装及使用指南 Yangmame 的博客（比较早期） Gentoo 安装教程 ayamir 的知乎记录（参考了 2 和 5） 2020-Gentoo 双系统安装指北 GTrush 的博客 新手 Gentoo 折腾记录 1 Jioushan 的博客 不完整的 Gentoo 安装 Google，Stack Overflow，gentoo wiki，arch wiki 等 ","date":"2023-06-18","objectID":"/posts/gentoo/gentoo%E5%AE%89%E8%A3%85%E5%B0%8F%E8%AE%B0/:0:2","tags":["Linux","Gentoo"],"title":"Gentoo 安装小记","uri":"/posts/gentoo/gentoo%E5%AE%89%E8%A3%85%E5%B0%8F%E8%AE%B0/"},{"categories":["Linux"],"content":"make.conf make.conf 可以说是 Gentoo 的核心了，针对 PC 的配置、优化以及对系统的预期基本上都是在这个文件中定义的，首先列出我的： # These settings were set by the catalyst build script that automatically # built this stage. # Please consult /usr/share/portage/config/make.conf.example for a more # detailed example. COMMON_FLAGS=\"-march=native -O2 -pipe\" CFLAGS=\"${COMMON_FLAGS}\" CXXFLAGS=\"${COMMON_FLAGS}\" FCFLAGS=\"${COMMON_FLAGS}\" FFLAGS=\"${COMMON_FLAGS}\" USE=\"X elogind mount cjk i3wm mpd network pulseaudio ipc opengl dbus -gnome -kde\" MAKEOPTS=\"-j6\" LC_MESSAGES=C EMERGE_DEFAULT_OPTS=\"--ask --verbose --load-average --newuse --with-bdeps=y --keep-going --deep\" CPU_FLAGS_X86=\"aes avx avx2 f16c fma3 mmx mmxext pclmul popcnt rdrand sse sse2 sse3 sse4_1 sse4_2 ssse3\" AUTO_CLEAN=\"yes\" PORTDIR=\"/var/db/repos/gentoo\" DISTDIR=\"/var/cache/distfiles\" PKGDIR=\"/var/chache/binpkgs\" PORTAGE_TMPDIR=\"/tmp\" PORTAGE_COMPRESS=\"zstd\" BINPKG_COMPRESS=\"zstd\" ACCEPT_LICENSE=\"*\" ACCEPT_KEYWORDS=\"~amd64\" GRUB_PLATFORMS=\"efi-64\" VIDEO_CARDS=\"nouveau\" GENTOO_MIRRORS=\"https://mirrors.tuna.tsinghua.edu.cn/gentoo\" MICROCODE_SIGNATURES=\"-S\" # NOTE: This stage was built with the bindist Use flag enabled # This sets the language of build output to English. # Please keep this setting intact when reporting bugs. LC_MESSAGES=C.utf8 # ccache FEATURES=\"ccache -test\" CCACHE_DIR=\"/var/cache/ccache\" # aria2 FETCHCOMMAND=\"/usr/bin/aria2c -d \\${DISTDIR} -o \\${FILE} --allow-overwrite=true --max-tries=5 --max-file-not-found=2 --max-concurrent-downloads=5 --connect-timeout=5 --timeout=5 --split=5 --min-split-size=2M --lowest-speed-limit=20K --max-connection-per-server=9 --uri-selector=feedback \\${URI}\" RESUMECOMMAND=\"${FETCHCOMMAND}\" ","date":"2023-06-18","objectID":"/posts/gentoo/gentoo%E5%AE%89%E8%A3%85%E5%B0%8F%E8%AE%B0/:0:3","tags":["Linux","Gentoo"],"title":"Gentoo 安装小记","uri":"/posts/gentoo/gentoo%E5%AE%89%E8%A3%85%E5%B0%8F%E8%AE%B0/"},{"categories":["Linux"],"content":"问题列举 安装 Gentoo 是相对容易的，但是往往会遇上很多奇怪的问题。比如常见的循环依赖，某个程序编译失败… 这种时候首先应该去 Gentoo Package 查找对应包是否有 Bug 记录，以及解决方法 这里主要列举的是我在安装过程中遇到的问题，以及解决方法 复杂密码换简单密码 Gentoo 默认是复杂密码，为了便于日常使用，改为简单密码： /etc/security/passwdqc.conf min=8,8,8,8,8 max=40 passphrase=0 match=4 similar=permit random=24 enforce=none retry=3 或者全局 USE -pam，我还没有尝试 eudev 还是 systemd-utils？ Gentoo 目前用 systemd-utils 替代了原本的 eudev，所以解决办法有： 使用 systemd-utils 管理设备，不要再安装 eudev，这是最简单的。官方的原话是：in general, you should not worry about installing anything *udev manually by yourself and you should imho not have anything like that in your world file. 如果你痛恨和 systemd 有关的一切，可以为 systemd-utils 包-udev USE，然后应该就可以安装 eudev 了。需要注意的是，eudev 不应该被加入到 world file 中。此外还有一些其他的 USE 也会影响，总之这很麻烦。建议还是不要折腾了，systemd-utils 只是从 systemd 中分离出来的组件而已，它包含了 udev Desktop profiles？ Desktop profiles 预设了很多 USE，并包含了一些 system 依赖。对于 KDE 和 GNOME 用户，Desktop profiles 中提供的增量可以省很多事。但是对于裸 WM 来说，没有必要为使用 Desktop，默认的 profiles 或者 systemd profiles 就可以了。在最小化的基础上，安装软件时检查 USE 并逐步添加自己的全局 USE /tmp 挂载 有时候 fstab 中会忘记挂载/tmp，这样/tmp 目录在磁盘中，在 portage 运行时主要以/tmp 作为暂存目录，可能会反复读写 SSD 降低寿命。将/tmp 挂载到内存中，毕竟内存更加皮实耐用 # size 的大小一般为内存大小的一半 tmpfs /tmp tmpfs rw,nosuid,noatime,nodev,size=16G,mode=1777 0 0 循环依赖问题 是在安装 polybar 的时候遇到了这个问题，其他人反应 vim 也有这个循环依赖。貌似不是个别人遇到的问题 循环依赖问题：循环依赖可以是多个，比如：A 依赖 B，B 依赖 C，而 C 又依赖 A。而在此过程中，A 的 USE 会对 B 造成影响，而 B 又对 C 造成影响，这种影响可以是+或者- USE。但是 C 又依赖了 A，与 A 的新 USE 冲突 如下报错信息: * Error: circular dependencies: ​ (media-libs/libsndfile-1.2.0:0/0::gentoo, ebuild scheduled for merge) depends on (media-sound/mpg123-1.31.3:0/0::gentoo, ebuild scheduled for merge) (buildtime_slot_op) (media-sound/pulseaudio-16.1:0/0::gentoo, ebuild scheduled for merge) (buildtime) (media-libs/libpulse-16.1-r2:0/0::gentoo, ebuild scheduled for merge) (buildtime) (media-libs/libsndfile-1.2.0:0/0::gentoo, ebuild scheduled for merge) (buildtime) ​ It might be possible to break this cycle by applying any of the following changes: - media-libs/libsndfile-1.2.0 (Change USE: +minimal) - media-sound/mpg123-1.31.3 (Change USE: -pulseaudio) ​ Note that this change can be reverted, once the package has been installed. ​ Note that the dependency graph contains a lot of cycles. Several changes might be required to resolve all cycles. Temporarily changing some use flag for all packages might be the better option. 解决方法： # 首先打破循环依赖，-1(oneshot) 避免把包写入 world 文件 USE=\"-pulseaudio\" emerge -1 media-sound/mpg123 # 安装 polybar，Global USE 定义了 pulseaudio emerge polybar # 成功安装后，再恢复以前的状态 USE=\"pulseaudio\" emerge -1 media-sound/mpg123 由于日常维护和debug太耗时，目前已放弃 Gentoo，此文章结束 ","date":"2023-06-18","objectID":"/posts/gentoo/gentoo%E5%AE%89%E8%A3%85%E5%B0%8F%E8%AE%B0/:0:4","tags":["Linux","Gentoo"],"title":"Gentoo 安装小记","uri":"/posts/gentoo/gentoo%E5%AE%89%E8%A3%85%E5%B0%8F%E8%AE%B0/"},{"categories":null,"content":"个人经历 本科毕业于北京邮电大学自动化学院，博士毕业于中国科学院高能物理研究所，研究方向为粒子加速器控制技术和加速器定时系统 目前在浪潮信息从事服务器 BIOS 和 BMC 的相关研究 ","date":"0001-01-01","objectID":"/about/:0:1","tags":null,"title":"","uri":"/about/"},{"categories":null,"content":"研究兴趣 Embedded system FPGA ZYNQ Kernel EPICS RISC V BIOS UEFI BMC RTOS ","date":"0001-01-01","objectID":"/about/:0:2","tags":null,"title":"","uri":"/about/"}]