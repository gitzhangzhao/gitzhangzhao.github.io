[{"categories":["Embedded System"],"content":"课题需要可能要在 ZYNQ 上多次部署 Linux 并测试，普通的脚本安装方式太过繁琐，Xilinx 的 Petalinux 工具简化了很多流程。这里记录了一些主要步骤，由于实验室 Vivado 版本，所以选择的 Petalinux 版本也不是最新的 2021.11 ","date":"2023-06-19","objectID":"/posts/petalinux/petalinux_1/:0:0","tags":["Petalinux","Linux"],"title":"Petalinux（一）： 安装使用及通过 linux 对 FPGA 的寄存器或者 RAM 进行读写","uri":"/posts/petalinux/petalinux_1/"},{"categories":["Embedded System"],"content":"why petalinux? 比分步编译更便捷的配置和编译源码 优势：petalinux 读取输入硬件配置，并根据硬件来自动的配置编译 u-boot，kernel，devicetree. 缺点：软件对系统版本，依赖版本要求比较高，配置相对麻烦。如果不按照规定好的顺序执行命令会遇上较多未知 BUG 目的：简化编译的过程，缩短时间并生成与硬件对应的正确的设备树文件 ","date":"2023-06-19","objectID":"/posts/petalinux/petalinux_1/:0:1","tags":["Petalinux","Linux"],"title":"Petalinux（一）： 安装使用及通过 linux 对 FPGA 的寄存器或者 RAM 进行读写","uri":"/posts/petalinux/petalinux_1/"},{"categories":["Embedded System"],"content":"petalinux 的安装 petalinux 对操作系统版本和依赖版本要求很高，只能在官方文档指定的发行版安装。这里以 petalinux 2017.04 为例 OS: ubuntu16.04(docker x86-64) Dependencies: sudo dpkg --add-architecture i386 sudo apt install libssl-dev flex bison chrpath socat autoconf libtool texinfo gcc-multilib libsdl1.2-dev libglib2.0-dev screen pax net-tools wget diffstat xterm gawk xvfb git make libncurse5-dev tftpd zlib1g libssl-dev gnupg tar unzip build-essential libtool-bin dialog cpio lsb-release zlib1g:i386 zlib1g-dev:i386 locales openjdk-8-jdk sudo dpkg-reconfigure locales export LANG=en_US.UTF-8 由于 Petalinux 依赖发行版版本，推荐采用 Docker 环境安装。请查看 Petalinux 2017.04 Docker 环境 ","date":"2023-06-19","objectID":"/posts/petalinux/petalinux_1/:0:2","tags":["Petalinux","Linux"],"title":"Petalinux（一）： 安装使用及通过 linux 对 FPGA 的寄存器或者 RAM 进行读写","uri":"/posts/petalinux/petalinux_1/"},{"categories":["Embedded System"],"content":"petalinux 的使用 创建一个 ZYNQ 的工程模板： petalinux-create --type project --template zynq --name petalinux 读取分析硬件所使用的开发版型号来配置： petalinux-config --get-hw-description /mnt/linux_base.sdk 配置内核和根文件系统： petalinux-config -c kernel petalinux-config -c rootfs 开始编译： petalinux-build 将编译好的工程打包输出： petalinux-package --boot --fsbl ./images/linux/zynq_fsbl.elf --fpga --u-boot --force 使用 qemu 虚拟化平台对产生的 BootLoader 和 linux 内核进行测试（可选） petalinux-boot --qemu --prebuilt 3 将输出的文件移动到开发板启动，或者使用 tftp 方式远程启动： image.ub: linux 的内核镜像，并且打包了设备树文件 plnx_arm-system.dtb, 在内存中运行的文件系统 ramdisk. # image.ub images { kernel@0 { description = \"Linux Kernel\"; data = /incbin/(\"zImage\"); type = \"kernel\"; arch = \"arm\"; os = \"linux\"; compression = \"none\"; load = \u003c0x8000\u003e; entry = \u003c0x8000\u003e; hash@1 { algo = \"sha1\"; }; }; fdt@0 { description = \"Flattened Device Tree blob\"; data = /incbin/(\"plnx_arm-system.dtb\"); type = \"flat_dt\"; arch = \"arm\"; compression = \"none\"; hash@1 { algo = \"sha1\"; }; }; ramdisk@0 { description = \"ramdisk\"; data = /incbin/(\"petalinux-user-image-plnx_arm.cpio.gz\"); type = \"ramdisk\"; arch = \"arm\"; os = \"linux\"; compression = \"none\"; hash@1 { algo = \"sha1\"; }; }; }; ","date":"2023-06-19","objectID":"/posts/petalinux/petalinux_1/:0:3","tags":["Petalinux","Linux"],"title":"Petalinux（一）： 安装使用及通过 linux 对 FPGA 的寄存器或者 RAM 进行读写","uri":"/posts/petalinux/petalinux_1/"},{"categories":["Embedded System"],"content":"petalinux 产生设备树的分析 使用 petalinux 的优势：自动分析硬件并产生设备树，也可以添加需要的部分并手动编译。 产生设备树的目录： $(project)/components/plnx_workspace/device-tree/device-tree-generation/ 设备树主要分两个部分： ARM CPU 相关的设备包括处理器内存，系统总线等等，在 zynq-7000.dtsi 中。（dtsi:设备树中描述 SOC 级的信息，一般不需要修改；dts: 设备树的源文件，修改设备树的主要对象；dtb: 由 dts 文件编译生成的二进制文件，由内核在启动时候读取并解析） petalinux 根据硬件的配置来生成 pl.dtsi 文件，文件内包括在根节点下的 FPGA 部分的设备树。 pl.dtsi 和 zynq-7000.dtsi 包含在 system-top.dts 内，手动添加的设备树也包含在内。 plnx_arm-system.dts 是处理了包含关系后的文件，编译生成 plnx_arm-system.dtb. pl.dtsi ---------| pcw.dtsi ---------|----\u003e system-top.dts ----\u003e plnx_arm-system.dts -----(dtc)----\u003e plnx_arm-system.dtb zynq-7000.dtsi ---| ","date":"2023-06-19","objectID":"/posts/petalinux/petalinux_1/:0:4","tags":["Petalinux","Linux"],"title":"Petalinux（一）： 安装使用及通过 linux 对 FPGA 的寄存器或者 RAM 进行读写","uri":"/posts/petalinux/petalinux_1/"},{"categories":["Embedded System"],"content":"实验：产生 GPIO 设备树文件，使用 Linux 内的 gpio 驱动程序，用文件 IO 方式驱动 led 系统描述：PS 和 PL 各有一个 led，通过 petalinux 产生一个完整 linux 系统，FPGA 端烧写一个 GPIO 控制器，输出 1 位信号到 R19 引脚，FPGA 的 R19 引脚连接了 pl 侧的 led 灯： set_property PACKAGE_PIN R19 [get_ports {gpio_out}] # R19引脚连接板上的led灯 set_property IOSTANDARD LVCMOS33 [get_ports {gpio_out}] linux 内核包含了 gpio 的驱动，可以根据设备树信息来自动检测硬件 $ cd /sys/class/gpio \u0026\u0026 ls export gpiochip906 gpiochip504 unexport # 访问/sys/class/gpio/目录，gpio906和gpio504分别是PS端和PL端的gpio控制器, export是内核提供的文件用于导出gpio的操作接口。 $ echo 906 \u003e export $ echo 504 \u003e export # 向export文件写入GPIO编号，就可以获得这个GPIO的操作接口。 $ ls export gpio906 gpiochip906 gpio504 gpiochip504 unexport # 新产生了gpio906和gpio504目录，目录中就是操作接口。 $ cd gpio906 \u0026\u0026 ls active_low direction power uevent device edge subsystem value # direction控制gpio的方向，value为gpio的输入输出值。 $ echo out \u003e direction $ echo 1 \u003e value # led灯灭 $ echo 0 \u003e value # led灯亮 # 通过一般的IO操作value这个文件就可以控制灯的亮灭。 产生的 GPIO 设备树部分(FPGA 侧): axi_gpio_0: gpio@41200000 { #gpio-cells = \u003c2\u003e; compatible = \"xlnx,xps-gpio-1.00.a\"; gpio-controller ; reg = \u003c0x41200000 0x10000\u003e; xlnx,all-inputs = \u003c0x0\u003e; xlnx,all-inputs-2 = \u003c0x0\u003e; xlnx,all-outputs = \u003c0x1\u003e; xlnx,all-outputs-2 = \u003c0x0\u003e; xlnx,dout-default = \u003c0x00000000\u003e; xlnx,dout-default-2 = \u003c0x00000000\u003e; xlnx,gpio-width = \u003c0x1\u003e; xlnx,gpio2-width = \u003c0x20\u003e; xlnx,interrupt-present = \u003c0x0\u003e; xlnx,is-dual = \u003c0x0\u003e; xlnx,tri-default = \u003c0xFFFFFFFF\u003e; xlnx,tri-default-2 = \u003c0xFFFFFFFF\u003e; }; ","date":"2023-06-19","objectID":"/posts/petalinux/petalinux_1/:0:5","tags":["Petalinux","Linux"],"title":"Petalinux（一）： 安装使用及通过 linux 对 FPGA 的寄存器或者 RAM 进行读写","uri":"/posts/petalinux/petalinux_1/"},{"categories":["Embedded System"],"content":"实验：直接将 FPGA 寄存器信号输出到 R19 引脚，通过 AXI-Lite 总线读写寄存器来控制 led 定义一个 32-bits 寄存器来接受总线信号，写入寄存器的值取一位输出到 led 灯 # 定义一个32位寄存器 reg [C_S_AXI_DATA_WIDTH-1:0] slv_reg0; # 将寄存器的第0位连接到输出信号 assign test_out = slv_reg0[0]; # 将总线模块打包，在test中调用AXI总线，添加一个输出信号test_out myip_v1_0_S00_AXI # ( .C_S_AXI_DATA_WIDTH(C_S00_AXI_DATA_WIDTH), .C_S_AXI_ADDR_WIDTH(C_S00_AXI_ADDR_WIDTH) ) myip_v1_0_S00_AXI_inst ( .S_AXI_ACLK(s00_axi_aclk), .S_AXI_ARESETN(s00_axi_aresetn), .S_AXI_AWADDR(s00_axi_awaddr), .S_AXI_AWPROT(s00_axi_awprot), .S_AXI_AWVALID(s00_axi_awvalid), .S_AXI_AWREADY(s00_axi_awready), .S_AXI_WDATA(s00_axi_wdata), .S_AXI_WSTRB(s00_axi_wstrb), .S_AXI_WVALID(s00_axi_wvalid), .S_AXI_WREADY(s00_axi_wready), .S_AXI_BRESP(s00_axi_bresp), .S_AXI_BVALID(s00_axi_bvalid), .S_AXI_BREADY(s00_axi_bready), .S_AXI_ARADDR(s00_axi_araddr), .S_AXI_ARPROT(s00_axi_arprot), .S_AXI_ARVALID(s00_axi_arvalid), .S_AXI_ARREADY(s00_axi_arready), .S_AXI_RDATA(s00_axi_rdata), .S_AXI_RRESP(s00_axi_rresp), .S_AXI_RVALID(s00_axi_rvalid), .S_AXI_RREADY(s00_axi_rready), .test_out(test_out) ); # 修改wrapper添加输出信号 output wire test_out # 绑定输出信号到led灯相连的引脚 set_property PACKAGE_PIN R19 [get_ports {test_out}] set_property IOSTANDARD LVCMOS33 [get_ports {test_out}] petalinux 根据系统硬件设计添加了 AXI-Lite 总线对应的设备树部分 # amba-axi总线的设备树部分 / { amba_pl: amba_pl { #address-cells = \u003c1\u003e; #size-cells = \u003c1\u003e; compatible = \"simple-bus\"; ranges ; myip_v1_0_0: myip_v1_0@43c00000 { # 寄存器的物理地址是0x43c00000 compatible = \"xlnx,myip-v1-0-1.0\"; reg = \u003c0x43c00000 0x10000\u003e; xlnx,s00-axi-addr-width = \u003c0x4\u003e; xlnx,s00-axi-data-width = \u003c0x20\u003e; }; }; }; 寄存器的物理地址是 0x43c00000，对这个地址的第一个字节的 0 位写值就可以控制 led 灯的亮灭 $ busybox devmem 0x43c00000 8 0x01 # 灯灭 $ busybox devmem 0x43c00000 8 0x00 # 灯亮 Q: 最小的寄存器组: 4 个(0x43c00000-0x43c0000f), 从 0x40000000-0x4fffffff 全部被映射到了最初的 16 个字节。 实际上被映射的物理内存区域有 1G，从地址 0x40000000-0x4fffffff ","date":"2023-06-19","objectID":"/posts/petalinux/petalinux_1/:0:6","tags":["Petalinux","Linux"],"title":"Petalinux（一）： 安装使用及通过 linux 对 FPGA 的寄存器或者 RAM 进行读写","uri":"/posts/petalinux/petalinux_1/"},{"categories":["Embedded System"],"content":"测试：从 Linux 端读写寄存器，寄存器连接一个宽度 16bit，深度 256 的 Block RAM，通过读写 3 个寄存器来实现对 Block RAM 的指定地址的读写。 由一个 TOP 模块，来例化了一个 AXI-Lite 总线接口，这个总线接口定义了 60 个寄存器并且引出。还有一个 BlockRAM 模块，将 AXI 总线定义的三个寄存器输入到 RAM 的控制接口里，然后通过对总线读写来控制 RAM。 AXI 总线模块： AXI_Lite axi_lite (.register00(AXI_Lite_register00), .register01(AXI_Lite_register01), .register02(AXI_Lite_register02), .register03(AXI_Lite_register03), .register04(AXI_Lite_register04), .register05(AXI_Lite_register05), .register06(AXI_Lite_register06), .register07(AXI_Lite_register07), .register08(AXI_Lite_register08), .register09(AXI_Lite_register09), .register10(AXI_Lite_register10), ...... 对 BlockRAM 的接口定义： bram_wrapper mappingRAM ( # 写地址：0x000-0x100(深度256) .BRAM_PORTA_0_addr(AXI_Lite_register01[7:0]), # 写时钟：FCLK_CLK0 .BRAM_PORTA_0_clk(s00_axi_aclk_0_1), # 写数据：16bit数据 .BRAM_PORTA_0_din(AXI_Lite_register02[15:0]), # PORTA使能 .BRAM_PORTA_0_en(1'b1), # PORTA写使能 .BRAM_PORTA_0_we(1'b1), # PORTB读地址 .BRAM_PORTB_0_addr(AXI_Lite_register03[7:0]), # PORTB读时钟 .BRAM_PORTB_0_clk(s00_axi_aclk_0_1), # PORTB读数据 .BRAM_PORTB_0_dout(w_ramout[15:0]), # PORTB读使能 .BRAM_PORTB_0_en(1'b1) ); ramout_0 -\u003e led(R19) # register ———————————————————— ————————————- | register01[7:0] | ————\u003e 写地址，输入到PORTA addr ——————\u003e | | ———————————————————— | register02[15:0] | ————\u003e 写数据，输入到PORTA din ——————\u003e | 256 x 16 | ———————————————————— | register03[7:0] | ————\u003e 读地址，输入到PORTB addr ——————\u003e | | ———————————————————— ————————————- | ramout[0] —————————————— | led \u003c———————————————————| ramout[15:0] |————————— —————————————— 测试过程: # 初始状态：ram内全部清零，ramout[0] 输出为0，\"led灯亮\" # 给RAM的写地址端口写入0x43c00004 $ busybox devmem 0x43c00004 8 0x55 # 给RAM的写数据端口写入16位数据0x0001 $ busybox devmem 0x43c00008 16 0x0001 此时RAM的0x55地址写入了数据 0000 0000 0000 0001 # 给0x43c0000c地址写入0x55，表示给RAM的读地址端口写0x55 $ busybox devmem 0x43c0000c 8 0x55 此时ramout的第0位由0变成了1，\"led灯灭\" # 把0x55的数据重新写为0 $ busybox devmem 0x43c00008 16 0x0000 \"led灯亮\" # 或者改变读地址的值 $ busybox devmem 0x43c0000c 8 0x56 \"led灯亮\" 上述实验证明数据写入 RAM 成功 ","date":"2023-06-19","objectID":"/posts/petalinux/petalinux_1/:0:7","tags":["Petalinux","Linux"],"title":"Petalinux（一）： 安装使用及通过 linux 对 FPGA 的寄存器或者 RAM 进行读写","uri":"/posts/petalinux/petalinux_1/"},{"categories":["Linux"],"content":"前言 安装Gentoo并不复杂，很多人混淆了复杂和耗时。在安装的过程中，大部分的时间都在做别的事情。同时，Gentoo的安装步骤是清晰的，Handbook和各路神仙的总结实际上已经很全面了。因此，没有必要再做重复的劳动，一些个性化的关键点记录就足够了。 为了使系统保持Suckless，尽量避免用不到的功能，我还是继续沿用裸wm的方式。简而言之：gentoo + openrc + i3wm + polybar + nvim。我的目标是尽量在一天内完成系统的整体安装，再用一周时间进行小修小补。而在流程化的步骤下，一天内的实际安装时间在1小时左右，而其余时间都在做其他事情。 此外，对于小新pro这种散热垃圾的Laptop，一个带风扇的散热架是必要的。否则，emerge -e @world 是真的会卡死（哭）。 ","date":"2023-06-18","objectID":"/posts/gentoo/gentoo%E5%AE%89%E8%A3%85%E5%B0%8F%E8%AE%B0/:1:0","tags":["Linux","Gentoo"],"title":"Gentoo安装小记","uri":"/posts/gentoo/gentoo%E5%AE%89%E8%A3%85%E5%B0%8F%E8%AE%B0/"},{"categories":["Linux"],"content":"安装步骤 Gentoo的安装大体上是规范的，但是针对不同用户的需求和理念，也有不一样的方式。或多或少的，存在一些坑 我在安装过程主要参考的几个链接： 官方Handbook，这是最权威的手册，当问题不确定时，以Handbook为准 Handbook 一篇较为详细的安装笔记，属于经验丰富的老玩家心得了，很有参考价值 Gentoo安装流程分享(step by step)，第一篇之基本系统的安装 OriPoin’s blog，详细介绍了Gentoo的优化方式，但是没必要采用O3，会带来很多未知问题 Emerge your world the lean way Optimize Your system the stupid way bitbili’s blog，非常非常详细的介绍了Gentoo的安装和使用 Gentoo Linux 安装及使用指南 Yangmame的安装教程 Gentoo安装教程 ayamir的知乎记录 2020-Gentoo双系统安装指北 Google，Stack Overflow，gentoo wiki，arch wiki等 ","date":"2023-06-18","objectID":"/posts/gentoo/gentoo%E5%AE%89%E8%A3%85%E5%B0%8F%E8%AE%B0/:2:0","tags":["Linux","Gentoo"],"title":"Gentoo安装小记","uri":"/posts/gentoo/gentoo%E5%AE%89%E8%A3%85%E5%B0%8F%E8%AE%B0/"},{"categories":["Linux"],"content":"make.conf make.conf可以说是Gentoo的核心了，针对PC的配置、优化以及对系统的预期基本上都是在这个文件中定义的，首先列出我的： # These settings were set by the catalyst build script that automatically # built this stage. # Please consult /usr/share/portage/config/make.conf.example for a more # detailed example. COMMON_FLAGS=\"-march=native -O2 -pipe\" CFLAGS=\"${COMMON_FLAGS}\" CXXFLAGS=\"${COMMON_FLAGS}\" FCFLAGS=\"${COMMON_FLAGS}\" FFLAGS=\"${COMMON_FLAGS}\" USE=\"X elogind mount cjk i3wm mpd network pulseaudio ipc opengl dbus -gnome -kde\" MAKEOPTS=\"-j6\" LC_MESSAGES=C EMERGE_DEFAULT_OPTS=\"--ask --verbose --load-average --newuse --with-bdeps=y --keep-going --deep\" CPU_FLAGS_X86=\"aes avx avx2 f16c fma3 mmx mmxext pclmul popcnt rdrand sse sse2 sse3 sse4_1 sse4_2 ssse3\" AUTO_CLEAN=\"yes\" PORTDIR=\"/var/db/repos/gentoo\" DISTDIR=\"/var/cache/distfiles\" PKGDIR=\"/var/chache/binpkgs\" PORTAGE_TMPDIR=\"/tmp\" PORTAGE_COMPRESS=\"zstd\" BINPKG_COMPRESS=\"zstd\" ACCEPT_LICENSE=\"*\" ACCEPT_KEYWORDS=\"~amd64\" GRUB_PLATFORMS=\"efi-64\" VIDEO_CARDS=\"nouveau\" GENTOO_MIRRORS=\"https://mirrors.tuna.tsinghua.edu.cn/gentoo\" MICROCODE_SIGNATURES=\"-S\" # NOTE: This stage was built with the bindist Use flag enabled # This sets the language of build output to English. # Please keep this setting intact when reporting bugs. LC_MESSAGES=C.utf8 # ccache FEATURES=\"ccache -test\" CCACHE_DIR=\"/var/cache/ccache\" # aria2 FETCHCOMMAND=\"/usr/bin/aria2c -d \\${DISTDIR} -o \\${FILE} --allow-overwrite=true --max-tries=5 --max-file-not-found=2 --max-concurrent-downloads=5 --connect-timeout=5 --timeout=5 --split=5 --min-split-size=2M --lowest-speed-limit=20K --max-connection-per-server=9 --uri-selector=feedback \\${URI}\" RESUMECOMMAND=\"${FETCHCOMMAND}\" ","date":"2023-06-18","objectID":"/posts/gentoo/gentoo%E5%AE%89%E8%A3%85%E5%B0%8F%E8%AE%B0/:3:0","tags":["Linux","Gentoo"],"title":"Gentoo安装小记","uri":"/posts/gentoo/gentoo%E5%AE%89%E8%A3%85%E5%B0%8F%E8%AE%B0/"},{"categories":["Linux"],"content":"问题列举 Gentoo默认是复杂密码，为了便于日常使用，改为简单密码： /etc/security/passwdqc.conf min=8,8,8,8,8 max=40 passphrase=0 match=4 similar=permit random=24 enforce=none retry=3 或者全局USE -pam，我还没有尝试 eudev还是systemd-utils？ Gentoo目前用systemd-utils替代了原本的eudev，所以解决办法有： 使用systemd-utils管理设备，不要再安装eudev，这是最简单的。官方的原话是：in general, you should not worry about installing anything *udev manually by yourself and you should imho not have anything like that in your world file. 如果你痛恨和systemd有关的一切，可以为systemd-utils包-udev USE，然后应该就可以安装eudev了。需要注意的是，eudev不应该被加入到world file中。此外还有一些其他的USE也会影响，总之这很麻烦。建议还是不要折腾了，systemd-utils只是从systemd中分离出来的组件而已，它包含了udev Desktop profiles？ Desktop profiles预设了很多USE，并包含了一些system依赖。对于KDE和GNOME用户，Desktop profiles中提供的增量可以省很多事。但是对于裸WM来说，没有必要为使用Desktop，默认的profiles或者systemd profiles就可以了。在最小化的基础上，安装软件时检查USE并逐步添加自己的全局USE ","date":"2023-06-18","objectID":"/posts/gentoo/gentoo%E5%AE%89%E8%A3%85%E5%B0%8F%E8%AE%B0/:4:0","tags":["Linux","Gentoo"],"title":"Gentoo安装小记","uri":"/posts/gentoo/gentoo%E5%AE%89%E8%A3%85%E5%B0%8F%E8%AE%B0/"},{"categories":null,"content":"概况 本科毕业于北京邮电大学自动化学院，博士毕业于中国科学院高能物理研究所。博士期间研究方向为粒子加速器控制技术和加速器定时系统 ","date":"0001-01-01","objectID":"/about/:1:0","tags":null,"title":"","uri":"/about/"},{"categories":null,"content":"研究兴趣 嵌入式 FPGA ZYNQ Kernel EPICS ","date":"0001-01-01","objectID":"/about/:2:0","tags":null,"title":"","uri":"/about/"}]