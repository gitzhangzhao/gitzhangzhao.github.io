<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>BIOS - 分类 - 张昭的Blog</title>
        <link>http://gitzhangzhao.github.io/categories/bios/</link>
        <description>BIOS - 分类 - 张昭的Blog</description>
        <generator>Hugo -- gohugo.io</generator><language>zh-cn</language><managingEditor>gitzhangzhao@gmail.com (张昭)</managingEditor>
            <webMaster>gitzhangzhao@gmail.com (张昭)</webMaster><lastBuildDate>Fri, 04 Aug 2023 14:00:29 &#43;0800</lastBuildDate><atom:link href="http://gitzhangzhao.github.io/categories/bios/" rel="self" type="application/rss+xml" /><item>
    <title>Boot 过程分析</title>
    <link>http://gitzhangzhao.github.io/posts/bios/boot/</link>
    <pubDate>Fri, 04 Aug 2023 14:00:29 &#43;0800</pubDate><author>gitzhangzhao@gmail.com (张昭)</author><guid>http://gitzhangzhao.github.io/posts/bios/boot/</guid>
    <description><![CDATA[<p><em><strong>申明: 本文严禁任何组织或个人在CSDN上进行转载,其他平台转载需经作者授权</strong></em></p>
<p>本篇文章详细完整的讨论现代处理器 boot 的过程，主要面向对象为 Intel、AMD 的 X86 架构和大部分 ARM 处理器架构</p>
<p></p>
<p><strong>前置概念</strong></p>
<ul>
<li>
<p>CPU 的引脚宝贵，只能用来连接高速设备（包括 Memory 和 PCIE 设备），原本通过北桥芯片来连接。但是目前，北桥芯片（用来连接内存和高速 PCIE）已经被集成进 CPU 中</p>
</li>
<li>
<p>低速的 IO（USB、SATA、eSPI 等）和其余的 PCIE 设备，不会直连 CPU 的，而是通过南桥芯片（PCH）来连接。PCH 是一块 IO 密集型芯片，BMC 芯片和 BIOS 芯片也是连接在 PCH 上的。然后 PCH 通过高速串行的总线 DMI 来和 CPU 连接，这样的目的是节约 CPU 的引脚（本质上是引脚复用）</p>
</li>
</ul>
<h2 id="after-cpu-加电或-reset-后到-bios-执行之前的阶段">After CPU 加电或 Reset 后，到 BIOS 执行之前的阶段</h2>
<h3 id="1-cpu-自检">1. CPU 自检</h3>
<ul>
<li>CPU 进行自身硬件初始化。初始化完成后，CPU 被设置为实地址模式，地址无分页。所有寄存器被初始化为特定的值， Cache、TLB（Translation Lookup Table）、BLB（Branch Target Buffer）这三个部件的内容被清空（Invalidate）</li>
</ul>
<h3 id="2-设置-cpu-寄存器">2. 设置 CPU 寄存器</h3>
<ul>
<li>寄存器 EIP（Instruction Pointer）、CS（Code Segment）被设置为 0x0000FFF0 和 0xFFFF0000。在实地址模式下（寄存器字长为 16 位），指令的物理地址是 CS &laquo; 4 + EIP。CPU 根据硬件设计，计算出第一条指令的地址：0xFFFF0000+0xFFF0 = 0xFFFFFFF0。随后，CPU 会从这个地址取指令并执行，需要在这个地址存放 BIOS 的代码</li>
</ul>
<h3 id="3-load-bios">3. Load BIOS</h3>
<ul>
<li>
<p>现在的问题是：在上电启动后，CPU 外围设备包括内存初始化还没有进行，没有内存可供使用，虽然有可以直接使用 Cache 替代内存的方法(Cache As RAM，CAR)，但总是没有直接用起来方便</p>
</li>
<li>
<p>但是，BIOS 代码是存放在一块 NOR Flash 中的，这块 Flash 在主板上通过 SPI 总线与 PCH 相连。NOR Flash 和我们用在 SSD 里面的 Flash 一个显著的不同就是它是字节寻址的，而不是块寻址。这就意味着它可以 XIP（eXecute in place），直接执行代码而不需要先 copy 到内存中</p>
</li>
<li>
<p>随后，CPU 去寻址 0xFFFFFFF0，PCH 的 SPI 总线默认 decode 该地址，从 Flash 芯片取指令；SPI 控制器响应 Flash 并返回内容给 DMI 总线（连接 PCH 和 CPU 的总线）；DMI 总线将指令给 CPU，开始解码执行。随后，通过这种方式一点一点 decode 运行，这个过程通常又称为 shadow</p>
</li>
</ul>
<h2 id="after-bios-被启动">After BIOS 被启动</h2>
<blockquote>
<p>在此之前，需要先明确什么是 BIOS？以及目前的 BIOS 是什么架构？</p>
</blockquote>
<p>BIOS 就是分级的配置各种硬件寄存器，Load Kernel, 启动 Boot Manager。这个过程是很复杂的，OS Loader 然后把控制权交接给 Kernel。最后，退居幕后给 Kernel 提供运行时服务</p>
<p>目前的 BIOS 采用 UEFI 标准设计，是一个简易的小操作系统，在完成主线任务的同时，也提供 UI、Shell 等方便交互的程序</p>
<blockquote>
<p>要了解 UEFI，还需要明确下面的概念：</p>
</blockquote>
<p><strong>UEFI 只是一个规范，没有具体的实现</strong>。目前的 BIOS 就是 UEFI，UEFI 就是一种 BIOS，不需要再进行区分。UEFI 是 Intel 及其小弟联合的规范，后来分为 UEFI 和 PI 两个部分，PI 后面再说。UEFI 侧重于和操作系统的接口，纯粹地是一个接口规范，它不会具体涉及平台固件是如何实现的。对于一台计算机，UEFI 固件提供服务，grub 这类 OS Loader 依赖于 UEFI 固件提供的接口来启动 Linux 内核。主要解决下面几个问题：</p>
<ul>
<li>定义哪些结构体、哪些指针、哪些函数、哪些 API？供 UEFI 应用使用</li>
<li>支持哪些功能？新功能的支持？</li>
</ul>
<p><strong>UEFI 是标准，是给别人用的</strong>。UEFI 的使用者包括但不仅限于操作系统加载器（OS Loader），安装程序（installers），来自引导设备的 ROM（adapter ROMS），操作系统的预诊断程序（pre-OS diagnostics），工具（utilities）以及操作系统运行时服务（OS runtimes-services）。通常，UEFI 是关于如何进行引导过程的。引导就是一个将控制权限连续，逐级地移交，从而启动整个 OS 的过程，这就是 OS Loader 所肩负的职责</p>
<p><strong>PI （Platform Initialization）规定如何实现一个 UEFI 环境</strong>，是另一个规范，从 UEFI 分离出来的。PI 描述了从平台重启直到构建出 UEFI 兼容环境所需的完整过程。“如何实现”这一内容是 PI 要解决的问题。与 UEFI 的开放不同，PI 对 pre-OS 引导程序，OS，以及他们的加载器，在极大程度上是无关的，因为 PI 中有太多与这些 UEFI 使用者无关的平台构造方面的程序。PI 描述了从平台重启直到构建出 UEFI 兼容环境所需的完整过程</p>
<hr>
<p>待续</p>
]]></description>
</item>
</channel>
</rss>
