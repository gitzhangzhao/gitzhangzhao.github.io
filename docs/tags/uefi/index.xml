<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>UEFI - 标签 - 张昭的Blog</title>
        <link>http://gitzhangzhao.github.io/tags/uefi/</link>
        <description>UEFI - 标签 - 张昭的Blog</description>
        <generator>Hugo -- gohugo.io</generator><language>zh-cn</language><managingEditor>gitzhangzhao@gmail.com (张昭)</managingEditor>
            <webMaster>gitzhangzhao@gmail.com (张昭)</webMaster><lastBuildDate>Fri, 04 Aug 2023 14:00:29 &#43;0800</lastBuildDate><atom:link href="http://gitzhangzhao.github.io/tags/uefi/" rel="self" type="application/rss+xml" /><item>
    <title>Boot 过程分析</title>
    <link>http://gitzhangzhao.github.io/posts/bios/boot/</link>
    <pubDate>Fri, 04 Aug 2023 14:00:29 &#43;0800</pubDate><author>gitzhangzhao@gmail.com (张昭)</author><guid>http://gitzhangzhao.github.io/posts/bios/boot/</guid>
    <description><![CDATA[<p><em><strong>申明: 本文严禁任何组织或个人在CSDN上进行转载,其他平台转载需经作者授权</strong></em></p>
<h1 id="启动过程完整分析">启动过程完整分析</h1>
<p>本篇文章详细完整的讨论现代处理器 boot 的过程，主要面向对象为 Intel、AMD 的 X86 架构和大部分 ARM 处理器架构</p>
<p></p>
<pre><code>&gt; **前置概念**

&gt; CPU 的引脚宝贵，只能用来连接高速设备（包括 Memory 和 PCIE 设备），原本通过北桥芯片来连接。但是目前，北桥芯片（用来连接内存和高速 PCIE）已经被集成进 CPU 中

&gt; 低速的 IO（USB、SATA、eSPI 等）和其余的 PCIE 设备，不会直连 CPU 的，而是通过南桥芯片（PCH）来连接。PCH 是一块 IO 密集型芯片，BMC 芯片和 BIOS 芯片也是连接在 PCH 上的。然后 PCH 通过高速串行的总线 DMI 来和 CPU 连接，这样的目的是节约 CPU 的引脚（本质上是引脚复用）
</code></pre>
<h2 id="after-cpu-加电或-reset-后到-bios-执行之前的阶段">After CPU 加电或 Reset 后，到 BIOS 执行之前的阶段</h2>
<h3 id="1-cpu-自检">1. CPU 自检</h3>
<pre><code>CPU 进行自身硬件初始化。初始化完成后，CPU 被设置为实地址模式，地址无分页。所有寄存器被初始化为特定的值， Cache、TLB（Translation Lookup Table）、BLB（Branch Target Buffer）这三个部件的内容被清空（Invalidate）
</code></pre>
<h3 id="2-设置-cpu-寄存器">2. 设置 CPU 寄存器</h3>
<pre><code>寄存器 EIP（Instruction Pointer）、CS（Code Segment）被设置为 0x0000FFF0 和 0xFFFF0000。在实地址模式下（寄存器字长为 16 位），指令的物理地址是 CS &lt;&lt; 4 + EIP。CPU 根据硬件设计，计算出第一条指令的地址：0xFFFF0000+0xFFF0 = 0xFFFFFFF0。随后，CPU 会从这个地址取指令并执行，需要在这个地址存放 BIOS 的代码
</code></pre>
<h3 id="3-load-bios">3. Load BIOS</h3>
<pre><code>现在的问题是：在上电启动后，CPU 外围设备包括内存初始化还没有进行，没有内存可供使用，虽然有可以直接使用 Cache 替代内存的方法(Cache As RAM，CAR)，但总是没有直接用起来方便

但是，BIOS 代码是存放在一块 NOR Flash 中的，这块 Flash 在主板上通过 SPI 总线与 PCH 相连。NOR Flash 和我们用在 SSD 里面的 Flash 一个显著的不同就是它是字节寻址的，而不是块寻址。这就意味着它可以 XIP（eXecute in place），直接执行代码而不需要先 copy 到内存中

随后，CPU 去寻址 0xFFFFFFF0，PCH 的 SPI 总线默认 decode 该地址，从 Flash 芯片取指令；SPI 控制器响应 Flash 并返回内容给 DMI 总线（连接 PCH 和 CPU 的总线）；DMI 总线将指令给 CPU，开始解码执行。随后，通过这种方式一点一点 decode 运行，这个过程通常又称为 shadow

---

待续

[1]: https://pic.imgdb.cn/item/64ccb42f1ddac507cc7bf288.png
</code></pre>
]]></description>
</item>
</channel>
</rss>
