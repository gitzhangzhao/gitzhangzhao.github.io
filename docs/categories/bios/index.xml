<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>BIOS - 分类 - 张昭的Blog</title>
        <link>http://gitzhangzhao.github.io/categories/bios/</link>
        <description>BIOS - 分类 - 张昭的Blog</description>
        <generator>Hugo -- gohugo.io</generator><language>zh-cn</language><managingEditor>gitzhangzhao@gmail.com (张昭)</managingEditor>
            <webMaster>gitzhangzhao@gmail.com (张昭)</webMaster><lastBuildDate>Tue, 29 Aug 2023 16:37:13 &#43;0800</lastBuildDate><atom:link href="http://gitzhangzhao.github.io/categories/bios/" rel="self" type="application/rss+xml" /><item>
    <title>UEFI BDS 阶段代码梳理</title>
    <link>http://gitzhangzhao.github.io/posts/bios/bds/</link>
    <pubDate>Tue, 29 Aug 2023 16:37:13 &#43;0800</pubDate><author>gitzhangzhao@gmail.com (张昭)</author><guid>http://gitzhangzhao.github.io/posts/bios/bds/</guid>
    <description><![CDATA[<h3 id="dxe-install-bds-protocol">DXE Install BDS Protocol</h3>
<ol>
<li>在 DXE 阶段的 Main 中，调用<code>CoreDispatcher() -&gt; CoreStartImage()</code>，进入各 DXE driver 的入口函数:</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="c1">// MdeModulePkg/Core/Dxe/DxeMain/DxeMain.c
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="n">Image</span><span class="o">-&gt;</span><span class="n">Status</span> <span class="o">=</span> <span class="n">Image</span><span class="o">-&gt;</span><span class="nf">EntryPoint</span> <span class="p">(</span><span class="n">ImageHandle</span><span class="p">,</span> <span class="n">Image</span><span class="o">-&gt;</span><span class="n">Info</span><span class="p">.</span><span class="n">SystemTable</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>此阶段会 load 并执行各 DXE 的驱动程序，而 BDS 就属于 DXE 的一个驱动，所以<code>BdsInitialize()</code>这个函数会在此时被执行：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="c1">// MdeModulePkg/Universal/BdsDxe/BdsDxe.inf
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="p">[</span><span class="n">Defines</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="n">INF_VERSION</span>                    <span class="o">=</span> <span class="mh">0x00010005</span>
</span></span><span class="line"><span class="cl"><span class="n">BASE_NAME</span>                      <span class="o">=</span> <span class="n">BdsDxe</span>
</span></span><span class="line"><span class="cl"><span class="n">MODULE_UNI_FILE</span>                <span class="o">=</span> <span class="n">BdsDxe</span><span class="p">.</span><span class="n">uni</span>
</span></span><span class="line"><span class="cl"><span class="n">FILE_GUID</span>                      <span class="o">=</span> <span class="mi">6</span><span class="n">D33944A</span><span class="o">-</span><span class="n">EC75</span><span class="o">-</span><span class="mi">4855</span><span class="o">-</span><span class="n">A54D</span><span class="o">-</span><span class="mi">809</span><span class="n">C75241F6C</span>
</span></span><span class="line"><span class="cl"><span class="n">MODULE_TYPE</span>                    <span class="o">=</span> <span class="n">DXE_DRIVER</span>                            <span class="c1">// BDS是DXE驱动
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">VERSION_STRING</span>                 <span class="o">=</span> <span class="mf">1.0</span>
</span></span><span class="line"><span class="cl"><span class="n">ENTRY_POINT</span>                    <span class="o">=</span> <span class="n">BdsInitialize</span>                         <span class="c1">// 驱动入口函数
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>入口函数<code>BdsInitialize()</code>调用<code>InstallMultipleProtocolInterfaces()</code>注册 BdsArchProtocol 到 DXE Core，该 Protocol 的 Guid 为<code>gEfiBdsArchProtocolGuid</code>，<code>*gBds</code>是一个指向 BdsArchProtocol 的指针，在<code>MdeModulePkg/Core/Dxe/DxeMain/DxeMain.c</code>开始时定义：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="c1">// `MdeModulePkg/Core/Dxe/DxeMain/DxeMain.c
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="n">EFI_BDS_ARCH_PROTOCOL</span>             <span class="o">*</span><span class="n">gBds</span>           <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>在 BDS 初始化阶段<code>BdsInitialize</code>，将该指针作为<code>InstallMultipleProtocolInterfaces()</code>的参数，目的是通过<code>gEfiBdsArchProtocolGuid</code>可以查询到<code>*gBds</code>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="c1">// MdeModulePkg/Universal/BdsDxe/BdsEntry.c
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// Install protocol interface
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">Handle</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">Status</span> <span class="o">=</span> <span class="n">gBS</span><span class="o">-&gt;</span><span class="nf">InstallMultipleProtocolInterfaces</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">                <span class="o">&amp;</span><span class="n">Handle</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                <span class="o">&amp;</span><span class="n">gEfiBdsArchProtocolGuid</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                <span class="o">&amp;</span><span class="n">gBds</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                <span class="nb">NULL</span>
</span></span><span class="line"><span class="cl">                <span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>在<code>InstallMultipleProtocolInterfaces()</code>之前，<code>*gBds</code>就已经指向 BDS 的入口函数<code>BdsEtry</code>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="c1">// MdeModulePkg/Universal/BdsDxe/BdsEntry.c
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">EFI_BDS_ARCH_PROTOCOL</span>  <span class="n">gBds</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="n">BdsEntry</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>再讨论一下 BDS 的 Protocol，<code>EFI_BDS_ARCH_PROTOCOL</code>是在<code>Bds.h</code>中定义的：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="c1">// MdePkg/Include/Bds.h
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">typedef</span> <span class="k">struct</span> <span class="n">_EFI_BDS_ARCH_PROTOCOL</span> <span class="n">EFI_BDS_ARCH_PROTOCOL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">typedef</span>
</span></span><span class="line"><span class="cl"><span class="nf">VOID</span>
</span></span><span class="line"><span class="cl"><span class="p">(</span><span class="n">EFIAPI</span> <span class="o">*</span><span class="n">EFI_BDS_ENTRY</span><span class="p">)(</span>
</span></span><span class="line"><span class="cl">  <span class="n">IN</span> <span class="n">EFI_BDS_ARCH_PROTOCOL</span>  <span class="o">*</span><span class="n">This</span>
</span></span><span class="line"><span class="cl"><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="n">_EFI_BDS_ARCH_PROTOCOL</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">EFI_BDS_ENTRY</span>    <span class="n">Entry</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>其中，<code>EFI_BDS_ENTRY </code>就是这个 protocol 的一个服务，对应了一个<code>PROTOCOL_INTERFACE</code>。在之前的<code>InstallMultipleProtocolInterfaces()</code>函数中，<code>Entry</code>函数被指向<code>EFI_BDS_ARCH_PROTOCOL</code>这个 Protocol 的例化<code>PROTOCOL_INTERFACE</code>中的<code>*Interface</code>指针。所以根据 Bds 的 Guid <code>EFI_BDS_ARCH_PROTOCOL_GUID</code>可以找到<code>EFI_BDS_ARCH_PROTOCOL</code>这个 Protocol，再根据这个 Protocol 找到<code>PROTOCOL_INTERFACE</code>实现，就可以找到具体的被注册的<code>BdsEntry()</code>函数了</p>
<p>另外，<code>*gBds</code>属于全局变量：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="c1">// MdeModulePkg/Core/Dxe/DxeMain.h
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">extern</span> <span class="n">EFI_BDS_ARCH_PROTOCOL</span>             <span class="o">*</span><span class="n">gBds</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>最后，在 Bds 的入口函数已经被安装后，可以直接通过<code>*gBds</code>指针访问<code>Entry()</code>函数了：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="n">gBds</span><span class="o">-&gt;</span><span class="nf">Entry</span> <span class="p">(</span><span class="n">gBds</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ol start="4">
<li></li>
</ol>
<hr>
<p>待续</p>
]]></description>
</item>
<item>
    <title>理解 UEFI 中的面向对象</title>
    <link>http://gitzhangzhao.github.io/posts/bios/uefi_1/</link>
    <pubDate>Tue, 08 Aug 2023 17:50:12 &#43;0800</pubDate><author>gitzhangzhao@gmail.com (张昭)</author><guid>http://gitzhangzhao.github.io/posts/bios/uefi_1/</guid>
    <description><![CDATA[<blockquote>
<p>UEFI 并不是一个面向对象的系统，它是基于 C 语言的，C 语言是一种过程式语言。然而，UEFI 使用了一些设计模式和技术来模拟面向对象编程的某些特性，如封装、抽象和多态</p>
</blockquote>
<ol>
<li>封装：UEFI 使用结构体（struct）来封装数据和操作数据的函数。例如，每个 UEFI 协议都定义为一个结构体，其中包含一组函数指针，这些函数提供了协议的行为。这种方式类似于面向对象编程中的类和方法（Kernel 中也是类似）</li>
<li>抽象：UEFI 使用接口（协议）来定义可以由多个不同的实现提供的行为。这类似于面向对象编程中的接口或抽象类</li>
<li>多态：UEFI 通过使用函数指针和接口（协议）来实现多态。不同的驱动可以提供同一接口的不同实现，然后通过接口来调用这些函数，实现运行时的多态</li>
<li>继承：UEFI 并没有提供类似于面向对象编程中的继承机制。然而，它使用了一种叫做“装饰者”模式的设计模式，通过这种方式，一个驱动可以“装饰”另一个驱动，提供额外的功能，这在某种程度上模拟了继承的行为</li>
</ol>
<h2 id="handle-和-protocol-的概念">handle 和 protocol 的概念</h2>
<p>UEFI 协议把访问设备的方法都抽象成了<code>Handle</code>和<code>Protocol</code>，Handle 是一个抽象的引用，用于引用一个或多个协议接口。一个设备便可以当成是一个 Handle（也可以当成是一个实例 Instance），而 Protocol 则是一个封装了某些操作方法的类（Class）。与面向对象有点区别的是，一个 Handle 可能是由多个 Protocols 组成的</p>
<p>Protocol 是一个由 struct 定义的结构体，这个结构体通常是由数据和函数指针组成。每个结构体的定义都有一个 GUID 与之对应。自然并不是所有的结构体都称之为 protocol，protocol 正如其名，它是一种规范，或称协议。比如要建立一个基于 UEFI Driver Model 的 Driver，就必须要绑定一个 EFI_DRIVER_BINGING_PROTOCOL 的实例，并且要自定义且实现 Support、Start、Stop 函数以及填充实例中其他的数据成员。再例如，EFI_SIMPLE_TEXT_INPUT_PROTOCOL 是一个协议，它定义了一组函数，这些函数可以用于从键盘读取输入</p>
<p><strong>Handle 和 Protocol 都是通过双向链表组织的</strong></p>
<p>定义的三个关键结构体：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="c1">// MdeModulePkg/Core/Dxe/Hand/Handle.h
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">/// IHANDLE - contains a list of protocol handles
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">UINTN</span>         <span class="n">Signature</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">/// All handles list of IHANDLE
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">LIST_ENTRY</span>    <span class="n">AllHandles</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">/// List of PROTOCOL_INTERFACE&#39;s for this handle
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">LIST_ENTRY</span>    <span class="n">Protocols</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">UINTN</span>         <span class="n">LocateRequest</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">/// The Handle Database Key value when this handle was last created or modified
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">UINT64</span>        <span class="n">Key</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="n">IHANDLE</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">/// PROTOCOL_ENTRY - each different protocol has 1 entry in the protocol
</span></span></span><span class="line"><span class="cl"><span class="c1">/// database.  Each handler that supports this protocol is listed, along
</span></span></span><span class="line"><span class="cl"><span class="c1">/// with a list of registered notifies.
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">UINTN</span>         <span class="n">Signature</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">/// Link Entry inserted to mProtocolDatabase
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">LIST_ENTRY</span>    <span class="n">AllEntries</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">/// ID of the protocol
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">EFI_GUID</span>      <span class="n">ProtocolID</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">/// All protocol interfaces
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">LIST_ENTRY</span>    <span class="n">Protocols</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">/// Registerd notification handlers
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">LIST_ENTRY</span>    <span class="n">Notify</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="n">PROTOCOL_ENTRY</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">UINTN</span>             <span class="n">Signature</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">/// Link on IHANDLE.Protocols
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">LIST_ENTRY</span>        <span class="n">Link</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">/// Back pointer
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">IHANDLE</span>           <span class="o">*</span><span class="n">Handle</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">/// Link on PROTOCOL_ENTRY.Protocols
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">LIST_ENTRY</span>        <span class="n">ByProtocol</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">/// The protocol ID
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">PROTOCOL_ENTRY</span>    <span class="o">*</span><span class="n">Protocol</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">/// The interface value
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">VOID</span>              <span class="o">*</span><span class="n">Interface</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">/// OPEN_PROTOCOL_DATA list
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">LIST_ENTRY</span>        <span class="n">OpenList</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">UINTN</span>             <span class="n">OpenListCount</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="n">PROTOCOL_INTERFACE</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>要明白 IHANDLE 这个结构体，就要明白 LIST_ENTRY 是如何被使用的。LIST_ENTRY 定义如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="c1">// MdeModulePkg/Include/LinkedList.h
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">/// _LIST_ENTRY structure definition.
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">struct</span> <span class="n">_LIST_ENTRY</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">LIST_ENTRY</span>    <span class="o">*</span><span class="n">ForwardLink</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">LIST_ENTRY</span>    <span class="o">*</span><span class="n">BackLink</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cp">#define _LIST_ENTRY LIST_ENTRY
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>首先，上面的<strong>LIST_ENTRY 这个结构体用于实现双向链表</strong>。但是与一般的链表实现方式不一样，它纯粹是 LIST*ENTRY 这个成员的链接，而不用在乎这个成员所在的结构体。一般的链表要求结点之间的类型一致，而这种链表只要求结构体存在 EFI_LIST_ENTRY 这个成员就够了。比如说 <code>IHANDLE *handle1,_handle2</code>;初始化后，<code>handle1-&gt;AllHandles-&gt;ForwardLink=handle2-&gt;AllHandles</code>; <code>handle2-&gt;AllHandles-&gt;BackLink=handle1-&gt;AllHandles</code>。这样 handle1 与 handle2 的 AllHandles 就链接到了一起。但是这样就只能进行 AllHandles 的遍历了，怎么样遍历 IHANLE 实例呢？。这时候就要用到_CR 宏，_CR 宏的定义如下：<code>#define \_CR(Record, TYPE, Field) ((TYPE _) ((CHAR8 _) (Record) - (CHAR8 _) &amp;(((TYPE \_) 0)-&gt;Field)))</code>，这个宏可以通过结构体实例的成员访问到实例本身</p>
<p><strong>IHANDLE 中的 AllHandles 成员用来链接 IHANDLE 实例</strong>。这个链表的头部是一个空结点，定义为：<code>EFI_LIST_ENTRY gHandleList</code>。一开始 <code>gHandleList-&gt;ForwardLink=gHandleList</code>; <code>gHandleList-&gt;BackLink=gHandleList</code>。每次 IHANDLE 都从 <code>gHandleList-&gt;BackLink</code> 插入进来，这个链表是一个环形双向链表。每当 Driver 建立一个新的 EFI_HANDLE 的时候就会插入到这条链表中来，被称之为 handle database</p>
<p><strong>Driver 会为 handle 添加多个 protocol</strong>，这些实例也是链表的形式存在。PROTOCOL_INTERFACE 的 link 用于连接以 IHANDLE 为空头结点以 PPOTOCOL_INTERFACE 为后续结点的链表</p>
<p>具体而言：IHANDLE 结构体定义中，Protocols 是一个 LIST_ENTRY 类型的成员，它是一个双向链表。这个链表用于链接所有的 PROTOCOL_INTERFACE 实例。在这个链表中，每个节点都包含两个指针：ForwardLink 和 BackLink。ForwardLink 指向链表中的下一个节点，BackLink 指向链表中的上一个节点。这样，通过遍历这个链表，就可以访问到所有的 PROTOCOL_INTERFACE 实例</p>
<p>此外，PROTOCOL_ENTRY 结构体是用来管理和跟踪已注册的协议的。每个协议都有一个对应的 PROTOCOL_ENTRY 实例，这个实例包含了协议的标识符和一个链表，这个链表链接了所有安装了这个协议的协议接口。例如，假设我们有一个协议 EFI_SIMPLE_TEXT_INPUT_PROTOCOL，它的标识符是{0x387477c1, 0x69c7, 0x11d2, {0x8e, 0x39, 0x00, 0xa0, 0xc9, 0x69, 0x72, 0x3b}}。当这个协议被注册时，会创建一个 PROTOCOL_ENTRY 实例，这个实例的 ProtocolID 成员被设置为这个标识符，Protocols 链表被初始化为一个空链表。然后，当一个驱动程序安装了一个 EFI_SIMPLE_TEXT_INPUT_PROTOCOL 协议接口到一个句柄上时，这个协议接口的 PROTOCOL_INTERFACE 实例就会被添加到 Protocols 链表中。这样，通过遍历 Protocols 链表，就可以找到所有安装了 EFI_SIMPLE_TEXT_INPUT_PROTOCOL 的协议接口</p>
<p>还有一个概念，就是 GUID，<strong>每个协议接口都由一个全局唯一标识符（GUID）来标识</strong>。当一个驱动程序或应用程序想要使用一个特定的协议接口时，它需要通过 GUID 来查找这个协议接口。这个过程通常是通过调用 LocateProtocol 或 OpenProtocol 这样的 UEFI 服务来完成的。例如，如果一个驱动程序想要使用 EFI_SIMPLE_TEXT_INPUT_PROTOCOL（这是一个用于从键盘读取输入的协议），它需要先获取这个协议的 GUID，然后调用 LocateProtocol 函数，传入这个 GUID 作为参数。如果成功，LocateProtocol 函数会返回一个指向 EFI_SIMPLE_TEXT_INPUT_PROTOCOL 接口的指针，然后驱动程序就可以通过这个指针来调用协议的函数。这种通过 GUID 来访问协议接口的机制使得 UEFI 可以在运行时动态地添加、删除和查找协议接口，这是一种非常灵活和强大的设计</p>
<p>根据此前的分析：在 UEFI 中，一个句柄（Handle）可以关联多个协议接口（Protocol Interface），这些协议接口被组织成一个链表，这个链表可以通过句柄的 Protocols 成员来访问。然而，在实际的使用中，通常不会直接操作这个链表。相反，UEFI 提供了一组服务，如 LocateProtocol 和 OpenProtocol，这些服务可以根据 GUID 来查找协议接口，这使得查找协议接口变得更加简单和安全。总的来说，虽然可以直接通过句柄的 Protocols 成员来访问所有的协议接口，但在实际的使用中，通常会通过 UEFI 提供的服务来查找和访问协议接口</p>
<p><strong>以上的概念用下图来描述：</strong></p>
<p></p>
<hr>
<p>待续</p>
]]></description>
</item>
<item>
    <title>Boot 过程分析</title>
    <link>http://gitzhangzhao.github.io/posts/bios/boot/</link>
    <pubDate>Fri, 04 Aug 2023 14:00:29 &#43;0800</pubDate><author>gitzhangzhao@gmail.com (张昭)</author><guid>http://gitzhangzhao.github.io/posts/bios/boot/</guid>
    <description><![CDATA[<p>本篇文章详细完整的讨论现代处理器 boot 的过程，主要面向对象为 Intel、AMD 的 X86 架构和大部分 ARM 处理器架构</p>
<p></p>
<p><strong>前置概念</strong></p>
<ul>
<li>
<p>CPU 的引脚宝贵，只能用来连接高速设备（包括 Memory 和 PCIE 设备），原本通过北桥芯片来连接。但是目前，北桥芯片（用来连接内存和高速 PCIE）已经被集成进 CPU 中</p>
</li>
<li>
<p>低速的 IO（USB、SATA、eSPI 等）和其余的 PCIE 设备，不会直连 CPU 的，而是通过南桥芯片（PCH）来连接。PCH 是一块 IO 密集型芯片，BMC 芯片和 BIOS 芯片也是连接在 PCH 上的。然后 PCH 通过高速串行的总线 DMI 来和 CPU 连接，这样的目的是节约 CPU 的引脚（本质上是引脚复用）</p>
</li>
</ul>
<h2 id="after-cpu-加电或-reset-后到-bios-执行之前的阶段">After CPU 加电或 Reset 后，到 BIOS 执行之前的阶段</h2>
<h3 id="1-cpu-自检">1. CPU 自检</h3>
<ul>
<li>CPU 进行自身硬件初始化。初始化完成后，CPU 被设置为实地址模式，地址无分页。所有寄存器被初始化为特定的值， Cache、TLB（Translation Lookup Table）、BLB（Branch Target Buffer）这三个部件的内容被清空（Invalidate）</li>
</ul>
<h3 id="2-设置-cpu-寄存器">2. 设置 CPU 寄存器</h3>
<ul>
<li>寄存器 EIP（Instruction Pointer）、CS（Code Segment）被设置为 0x0000FFF0 和 0xFFFF0000。在实地址模式下（寄存器字长为 16 位），指令的物理地址是 CS &laquo; 4 + EIP。CPU 根据硬件设计，计算出第一条指令的地址：0xFFFF0000+0xFFF0 = 0xFFFFFFF0。随后，CPU 会从这个地址取指令并执行，需要在这个地址存放 BIOS 的代码</li>
</ul>
<h3 id="3-load-bios">3. Load BIOS</h3>
<ul>
<li>
<p>现在的问题是：在上电启动后，CPU 外围设备包括内存初始化还没有进行，没有内存可供使用，虽然有可以直接使用 Cache 替代内存的方法(Cache As RAM，CAR)，但总是没有直接用起来方便</p>
</li>
<li>
<p>但是，BIOS 代码是存放在一块 NOR Flash 中的，这块 Flash 在主板上通过 SPI 总线与 PCH 相连。NOR Flash 和我们用在 SSD 里面的 Flash 一个显著的不同就是它是字节寻址的，而不是块寻址。这就意味着它可以 XIP（eXecute in place），直接执行代码而不需要先 copy 到内存中</p>
</li>
<li>
<p>随后，CPU 去寻址 0xFFFFFFF0，PCH 的 SPI 总线默认 decode 该地址，从 Flash 芯片取指令；SPI 控制器响应 Flash 并返回内容给 DMI 总线（连接 PCH 和 CPU 的总线）；DMI 总线将指令给 CPU，开始解码执行。随后，通过这种方式一点一点 decode 运行，这个过程通常又称为 shadow</p>
</li>
</ul>
<h2 id="after-bios-被启动">After BIOS 被启动</h2>
<blockquote>
<p>在此之前，需要先明确什么是 BIOS？以及目前的 BIOS 是什么架构？</p>
</blockquote>
<p><strong>需要明确的是，启动 OS 并不一定需要使用 BIOS</strong>，我们常见的嵌入式设备（arm），它们使用 BootLoader 来引导 OS（一般是指 Linux），BootLoader 相当于 BIOS 的角色，负责初始化内存，加载 OS 内核等。由于嵌入式设备的硬件环境各不相同，没有统一的标准，所以在不同嵌入式硬件上运行 OS 每次都得修改配置 BootLoader 和内核，比较繁琐</p>
<p><strong>BIOS 存在的条件是统一的硬件，像嵌入式这种就完全没有必要了</strong>。传统的 PC 设备和服务器则不一样，整个硬件系统架构都是有标准的，早期由 Intel，IBM，AMD 等大厂制定，发展至今已成为一套成熟且统一的系统架构。同样的，既然硬件能统一，OS 也可以做到一致。此时，要让 OS 可以在硬件工作起来，还需要一段引导程序，负责检初始化硬件（如初始化内存），检测硬件资源（如可否正常分配资源）等，前面这些都正常了，说明 OS 正常运行的条件满足了，此时做最后一步就是引导启动 OS 了，这一阶段的程序就称为 BIOS。BIOS 就是分级的配置各种硬件寄存器，Load Kernel, 启动 Boot Manager。这个过程是很复杂的，OS Loader 然后把控制权交接给 Kernel。最后，退居幕后给 Kernel 提供运行时服务</p>
<p><strong>目前的 BIOS 采用 UEFI 标准设计</strong>，是一个简易的小操作系统，在完成主线任务的同时，也提供 UI、Shell 等方便交互的程序</p>
<blockquote>
<p>早期以汇编为主的 BIOS 经过发展被目前的 UEFI BIOS 所替代。要了解 UEFI，还需要明确下面的概念：</p>
</blockquote>
<p>首先，UEFI 只是一个规范，没有具体的实现。<strong>就目前而言，BIOS 就是指 UEFI，UEFI 就是 BIOS，不需要再进行区分</strong>。UEFI 是 Intel 及其小弟联合的规范，后来分为 UEFI 和 PI 两个部分，PI 后面再说。UEFI 侧重于和操作系统的接口，纯粹地是一个接口规范，它不会具体涉及平台固件是如何实现的。对于一台计算机，UEFI 固件提供服务，grub 这类 OS Loader 依赖于 UEFI 固件提供的接口来启动 Linux 内核。UEFI 是一套规范，阐述了 UEFI 需要实现哪些功能，这些功能该怎么实现，实现的时候需要使用什么名称。比如规范中有一个 USB 相关的定义，有一个 USB Host Controller Protocol，用来控制 USB 控制器，这个 Protocol 需要由 13 个函数组，每个函数都有详细注明了它的使用方法，传入传出参数，返回值等，但是具体函数内部具体如何实现是不做要求的，只要能实现对应的功能即可:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">typedef</span> <span class="k">struct</span> <span class="n">_EFI_USB2_HC_PROTOCOL</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">EFI_USB2_HC_PROTOCOL_GET_CAPABILITY</span>              <span class="n">GetCapability</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">EFI_USB2_HC_PROTOCOL_RESET</span>                       <span class="n">Reset</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">EFI_USB2_HC_PROTOCOL_GET_STATE</span>                   <span class="n">GetState</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">EFI_USB2_HC_PROTOCOL_SET_STATE</span>                   <span class="n">SetState</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">EFI_USB2_HC_PROTOCOL_CONTROL_TRANSFER</span>            <span class="n">ControlTransfer</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">EFI_USB2_HC_PROTOCOL_BULK_TRANSFER</span>               <span class="n">BulkTransfer</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">EFI_USB2_HC_PROTOCOL_ASYNC_INTERRUPT_TRANSFER</span>    <span class="n">AsyncInterruptTransfer</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">EFI_USB2_HC_PROTOCOL_ASYNC_INTERRUPT_TRANSFER</span>    <span class="n">SyncInterruptTransfer</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">EFI_USB2_HC_PROTOCOL_ISOCHRONOUS_TRANSFER</span>        <span class="n">IsochronousTransfer</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">EFI_USB2_HC_PROTOCOL_ASYNC_ISOCHRONOUS_TRANSFER</span>  <span class="n">AsyncIsochronousTransfer</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">EFI_USB2_HC_PROTOCOL_GET_ROOTHUB_PORT_STATUS</span>     <span class="n">GetRootHubPortStatus</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">EFI_USB2_HC_PROTOCOL_SET_ROOTHUB_PORT_FEATURE</span>    <span class="n">SetRootHubPortFeature</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">EFI_USB2_HC_PROTOCOL_CLEAR_ROOTHUB_PORT_FEATURE</span>  <span class="n">ClearRootHubPortFeature</span>
</span></span><span class="line"><span class="cl">  <span class="n">UINT16</span>                                           <span class="n">MajorRevision</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">UINT16</span>                                           <span class="n">MinorRevision</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="n">EFI_USB2_HC_PROTOCOL</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>UEFI 是标准，是给别人用的</strong>。UEFI 的使用者包括但不仅限于操作系统加载器（OS Loader），安装程序（installers），来自引导设备的 ROM（adapter ROMS），操作系统的预诊断程序（pre-OS diagnostics），工具（utilities）以及操作系统运行时服务（OS runtimes-services）。通常，UEFI 是关于如何进行引导过程的。引导就是一个将控制权限连续，逐级地移交，从而启动整个 OS 的过程，这就是 OS Loader 所肩负的职责</p>
<p><strong>UEFI 的规范可以当做是一套库函数，是用来被调用的</strong>，那要怎么去使用这些库呢？整套引导的代码该从哪里写起？这时候一份称为《Platform Initialization Specification》（简称 PI Spec）的手册派上用场了</p>
<p><strong>PI （Platform Initialization）规定了如何实现一个 UEFI 环境</strong>，是另一个规范，从 UEFI 分离出来的。PI 描述了从平台重启直到构建出 UEFI 兼容环境所需的完整过程。“如何实现”这一内容是 PI 要解决的问题。与 UEFI 的开放不同，PI 对 pre-OS 引导程序，OS，以及他们的加载器，在极大程度上是无关的，因为 PI 中有太多与这些 UEFI 使用者无关的平台构造方面的程序。PI 描述了从平台重启直到构建出 UEFI 兼容环境所需的完整过程。PI 手册定义了 UEFI 代码的各个启动阶段（除了 SEC 阶段）的流程，每个阶段需要做哪些操作。此外，还定义了启动过程中使用到的一些机制，如 HOB，SMM，S3 Resume 等</p>
<blockquote>
<p>基于以上的规范，UEFI 代码 EDK 便可以实现了，目前最新的代码已经更名为 EDK2，是目前所有 UEFI 固件的基础代码</p>
</blockquote>
<p><strong>EDK2 主要是实现手册所定义的各项基本功能，是一套通用的代码</strong>，并不能直接拿来使用，还需要根据各个平台的差异做修改或对功能进行扩充，此时就有了做这项工作 UEFI 代码厂商，他们会整合优化 EDK2 的基础代码和芯片厂商（Intel、AMD 还有中国的龙芯，兆芯等）的核心代码，有些还会加进一些自家的特色功能，让代码使用起来更加便捷。AMI 就是比较著名的厂家，他们的代码都进行了深度的定制，很多功能几乎只要改改 enable 跟 disable 就可以了</p>
<p><strong>在了解了基本概念后，开始分析 BIOS 的执行</strong></p>
<h3 id="bios-进入">BIOS 进入</h3>
<hr>
<p>待续</p>
]]></description>
</item>
</channel>
</rss>
