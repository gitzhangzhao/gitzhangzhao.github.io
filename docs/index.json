[{"categories":["Embedded System"],"content":"对于 Linux 远程启动是很普遍的，在 Petalinux 上配置远程启动很简单，并且 Petalinux 会自动配置 U-Boot 变量并增加内核启动参数 2022.05 ","date":"2023-06-19","objectID":"/posts/petalinux/petalinux_2/:0:0","tags":["Petalinux","ZYNQ","NFS"],"title":"Petalinux(二)：远程启动","uri":"/posts/petalinux/petalinux_2/"},{"categories":["Embedded System"],"content":"1. 目标 内核文件通过 tftp 从 host 下载并启动，挂载的根文件系统为网络文件系统（nfs） 基本过程：BOOT.BIN 文件包括了硬件 bit 流、FSBL 和 U-Boot，这个文件放在板卡的 tf 卡或者 QSPI Flash 中，用于启动 Linux 内核。Linux 内核和设备树文件 image.ub 放在 host 上的 tftpboot 目录，U-Boot 通过 tftp 下载内核镜像到内存中，并启动内核。内核启动后，挂载 host 上的 nfs 文件系统作为根文件系统 ","date":"2023-06-19","objectID":"/posts/petalinux/petalinux_2/:1:0","tags":["Petalinux","ZYNQ","NFS"],"title":"Petalinux(二)：远程启动","uri":"/posts/petalinux/petalinux_2/"},{"categories":["Embedded System"],"content":"2. 组成：FSBL、U-Boot、kernel 和根文件系统 FSBL： 第二阶段引导文件，由 vivado 提供源码，用于在第一阶段引导代码（固定在芯片内的 rom 里）结束后，初始化一些 ZYNQ 常用的外设，由于是外部代码，可以根据需要自行修改 U-Boot： 第二阶段引导结束后将跳转执行 U-Boot，fsbl 没有远程拷贝的功能，所以 U-Boot 必须放置在板卡的可启动 ROM 内，主要为 TF 卡和 QSPI FLASH；U-Boot 具有板卡上大部分设备的驱动程序，可以配置网络，下载镜像并拷贝进内存中，最后跳转到内核的启动点 device tree： 设备树文件描述了硬件设备的信息，需要被 U-Boot 拷贝进内存并告诉内核地址，内核启动后读取设备树文件获取设备信息 Kernel： 内核镜像，有 uImage、zImage 等不同形式，具有不同的压缩方式与格式。U-Boot 支持各种形式的内核镜像，内核可以在本地部署也可以通过 tftp 或者 nfs 协议从 host 下载内核镜像，内核启动后初始化硬件并挂载根文件系统 根文件系统： 内核可以挂载本地 eMMC、TF 卡和远程 host 中的文件系统 ","date":"2023-06-19","objectID":"/posts/petalinux/petalinux_2/:2:0","tags":["Petalinux","ZYNQ","NFS"],"title":"Petalinux(二)：远程启动","uri":"/posts/petalinux/petalinux_2/"},{"categories":["Embedded System"],"content":"3. BOOT 所需文件的来源 FSBL： 由 VIVADO SDK 工具提供，使用 make 编译 U-Boot： 由官方发布源码，Xilinx 添加一些独有驱动，在 Github Xilinx 代码仓库维护，使用 make 编译 Kernel： Linux 内核源码，使用 make 编译 device tree： 由内核提供一部分，Xilinx 提供一部分，用户也可以自行添加，使用内核工具中的设备树专用编译器编译 根文件系统： 不同发行版针对不同体系结构有不同的根文件系统，目录结构固定，直接解压到被挂载的根目录，不需要编译 ","date":"2023-06-19","objectID":"/posts/petalinux/petalinux_2/:3:0","tags":["Petalinux","ZYNQ","NFS"],"title":"Petalinux(二)：远程启动","uri":"/posts/petalinux/petalinux_2/"},{"categories":["Embedded System"],"content":"各种文件的组织方式 由于最终都是将各种镜像拷贝进内存，被在每一阶段的最后跳转到下一阶段的执行点，所以理论上 BOOT 的过程可以将各种文件放置在不同的位置，或者相同位置下的不同文件 BOOT 文件的打包 FSBL、U-Boot、kernel、device tree 一起打包进 BOOT.BIN FSBL、U-Boot 打包进 BOOT.BIN，kernel 和 device tree 打包进 image.ub FSBL、U-Boot 打包进 BOOT.BIN，kernel 和 device tree 独立为 zImage 和 system.dtb 在 2 或 3 的基础上，BOOT.BIN 放在本地，kernel 和 device tree 放在远端，U-Boot 通过 tftp 协议从网络下载 kernel 和 device tree 在 2 或 3 的基础上，BOOT.BIN 放在本地，kernel 和 device tree 放在远端，U-Boot 通过 nfs 协议从网络下载 kernel 和 device tree 在 1、2、3、4、5 的基础上，BOOT.BIN 可以放在 tf 卡的第一分区或者 QSPI Flash 中 在 1、2、3、4、5、6 的基础上，根文件系统可以放在 tf 卡的非第一分区、eMMC 或通过 nfs 从网络挂载 ","date":"2023-06-19","objectID":"/posts/petalinux/petalinux_2/:3:1","tags":["Petalinux","ZYNQ","NFS"],"title":"Petalinux(二)：远程启动","uri":"/posts/petalinux/petalinux_2/"},{"categories":["Embedded System"],"content":"4. 使用手动编译生成可远程启动的镜像文件 使用手动编译 U-Boot 和 kernel 过程略 ","date":"2023-06-19","objectID":"/posts/petalinux/petalinux_2/:4:0","tags":["Petalinux","ZYNQ","NFS"],"title":"Petalinux(二)：远程启动","uri":"/posts/petalinux/petalinux_2/"},{"categories":["Embedded System"],"content":"配置 U-Boot 环境变量通过 tftp 启动 linux kernel 在 U-Boot 启动后，通过配置一些 U-Boot 环境变量来远程启动内核，这里假设内核和设备树文件放在 host 的/tftpboot 目录内 # 设置本机ip地址和host ip地址 zynq\u003e setenv ipaddr 192.168.206.187 zynq\u003e setenv serverip 192.168.206.187 # 将内核镜像zImage和设备树文件system.dtb通过tfpt下载进内存 # 将内核镜像下载到内存地址0x10000000 zynq\u003e tftpboot 10000000 zImage # 将设备树文件下载到内存地址 zynq\u003e tftpboot 10080000 system.dtb # 将地址传入bootz命令，启动zImage形式的内核 zynq\u003e bootz 10000000 - 10080000 由于手动编译设备树和内核文件分离，而挂载文件系统部分相似，后续挂载 nfs 见下一章节介绍 ","date":"2023-06-19","objectID":"/posts/petalinux/petalinux_2/:4:1","tags":["Petalinux","ZYNQ","NFS"],"title":"Petalinux(二)：远程启动","uri":"/posts/petalinux/petalinux_2/"},{"categories":["Embedded System"],"content":"5. 使用 petalinux 工具生成可远程启动镜像 在执行 petalinux-config 命令需要修改的部分 修改 U-Boot 配置 可以修改 netboot offset，即从远程下载镜像到内存中的地址偏移，远程 tftp server 的 IP 地址 修改镜像打包相关配置 修改根文件系统位置、nfs 文件系统挂载目录、nfs server IP 地址、内核镜像名、以及 host tftpboot 目录 build 整个系统 $ petalinux-build 将编译后的输出文件打包成适合部署的格式 # 一般 BOOT.BIN 包含 fsbl 文件、bitstream 和 U-Boot 文件 $ petalinux-package --boot --fsbl --fpga --u-boot --force 其余部分不需要修改，相关根文件系统挂载方式等等配置会生成相关内核参数，内核参数由 U-Boot 在启动时传递给内核 这里和之前手动编译生成启动镜像不同，没有下载设备树文件 system.dtb，原因是使用 petalinux 打包的内核镜像 image.ub 中是包含了设备树文件的。因为 image.ub 文件是通过 mkimage 命令制作的，是将内核镜像 zImage 和设备树 system.dtb 打包到一起 ","date":"2023-06-19","objectID":"/posts/petalinux/petalinux_2/:5:0","tags":["Petalinux","ZYNQ","NFS"],"title":"Petalinux(二)：远程启动","uri":"/posts/petalinux/petalinux_2/"},{"categories":["Embedded System"],"content":"6. 配置 U-Boot 启动 petalinux 编译的内核 ","date":"2023-06-19","objectID":"/posts/petalinux/petalinux_2/:6:0","tags":["Petalinux","ZYNQ","NFS"],"title":"Petalinux(二)：远程启动","uri":"/posts/petalinux/petalinux_2/"},{"categories":["Embedded System"],"content":"基本步骤 基本步骤和手动编译启动内核一致，在远程 host 上需要具有 nfs 服务器，配置好 nfs 目录，并将根文件系统解压进该目录 在设置 IP 地址这一步，U-Boot 会先通过 DHCP 从 server 申请 IP 地址，如果 server 上有 DHCP 服务器，U-Boot 就会自动设置 ipaddr 这个环境变量，可以通过 printenv 打印出所有环境变量，serverip 这个环境变量是在 petalinux 配置阶段设置的 netboot 这个环境变量是 U-Boot 设置的，为 tfptboot ${netstart} ${kernel_img} \u0026\u0026 bootm, 其中 kernel_img 就是 image.ub 步骤： # 设置本机 ip 地址和 host ip 地址 zynq\u003e setenv ipaddr 192.168.138.2 zynq\u003e setenv servimagee通过 tfpt 下载进内存 # netboot 这个环境变量是 U-Boot 设置的，为 tfptboot ${netstart} ${kernel_img} \u0026\u0026 bootm, 其中 kernel_img 就是 image.ub zynq\u003e run netboot ","date":"2023-06-19","objectID":"/posts/petalinux/petalinux_2/:6:1","tags":["Petalinux","ZYNQ","NFS"],"title":"Petalinux(二)：远程启动","uri":"/posts/petalinux/petalinux_2/"},{"categories":["Embedded System"],"content":"配置默认启动命令 设置 U-Boot 默认命令，U-Boot 启动后会先配置网络，网络配置完成后就会进入倒计时，倒计时结束执行 bootcmd 中的命令，如果想自动 boot，只需要 zynq\u003e setenv bootcmd run netboot # 保存所有环境变量到 qspi zynq\u003e saveenv ","date":"2023-06-19","objectID":"/posts/petalinux/petalinux_2/:6:2","tags":["Petalinux","ZYNQ","NFS"],"title":"Petalinux(二)：远程启动","uri":"/posts/petalinux/petalinux_2/"},{"categories":["Embedded System"],"content":"配置内核参数环境变量 在设备树文件中有一个 chosen 字段，里面设置了内核参数变量 bootargs，U-Boot 中如果不手动配置这个变量，使用的是设备树文件中的内核参数，但是 U-Boot 中的 bootargs 环境变量具有最高优先级 ","date":"2023-06-19","objectID":"/posts/petalinux/petalinux_2/:6:3","tags":["Petalinux","ZYNQ","NFS"],"title":"Petalinux(二)：远程启动","uri":"/posts/petalinux/petalinux_2/"},{"categories":["Embedded System"],"content":"挂载 nfs 文件系统 决定根文件系统的方式主要是内核的启动参数，配置从 nfs 挂载，bootargs 应该被设置为 # petalinux会根据选项自动配置该变量 zynq\u003e setenv bootargs ‘console=ttyPS0,115200 root=/dev/nfs rw nfsroot=192.168.138.1:/home/zynq/linux/nfs/rootfs,tcp ip=dhcp’ 这个环境变量意义是，根文件系统使用 nfs 的方式以 rw 挂载，根文件系统目录在 192.168.138.1:/home/zynq/linux/nfs/rootfs，本机 ip 地址配置为 dhcp 方式从 server 获取 内核启动后会自动挂载 nfs 文件系统，如果挂载成功，内核就会启动完成 ","date":"2023-06-19","objectID":"/posts/petalinux/petalinux_2/:7:0","tags":["Petalinux","ZYNQ","NFS"],"title":"Petalinux(二)：远程启动","uri":"/posts/petalinux/petalinux_2/"},{"categories":["Embedded System"],"content":"在挂载 nfs 时遇到问题：内核启动报错 VFS: Unable to mount root fs via NFS, trying floppy. VFS: Cannot open root device \"nfs\" or unknown-block(2,0): error -6 不能成功挂载的原因 防火墙问题 $ ufw disable 由于 nfs 版本不支持 目前新安装的 nfs 为 v4 版本，v2 已经废弃，但是很多比较老的内核不支持 v4，可能由于 nfs 解决方法 在内核配置中打开 nfs 文件系统对 nfs v4 的支持： \u003c*\u003e NFS client support for NFS version 4 在 nfs server 端的配置中打开对 nfs v2、nfs v3 和 nfs v4 的支持 $ echo 'RPCNFSDOPTS=\"--nfs-version 2,3,4 --debug --syslog\"' \u003e\u003e /etc/default/nfs-kernel-server $ systmectl restart nfs-server.service ","date":"2023-06-19","objectID":"/posts/petalinux/petalinux_2/:7:1","tags":["Petalinux","ZYNQ","NFS"],"title":"Petalinux(二)：远程启动","uri":"/posts/petalinux/petalinux_2/"},{"categories":["Embedded System"],"content":"课题需要可能要在 ZYNQ 上多次部署 Linux 并测试，普通的脚本安装方式太过繁琐，Xilinx 的 Petalinux 工具简化了很多流程。这里记录了一些主要步骤，由于实验室 Vivado 版本，所以选择的 Petalinux 版本也不是最新的 2021.11 ","date":"2023-06-19","objectID":"/posts/petalinux/petalinux_1/:0:0","tags":["Petalinux","ZYNQ","NFS"],"title":"Petalinux(一)：安装使用","uri":"/posts/petalinux/petalinux_1/"},{"categories":["Embedded System"],"content":"why petalinux? 比分步编译更便捷的配置和编译源码 优势：petalinux 读取输入硬件配置，并根据硬件来自动的配置编译 u-boot，kernel，devicetree. 缺点：软件对系统版本，依赖版本要求比较高，配置相对麻烦。如果不按照规定好的顺序执行命令会遇上较多未知 BUG 目的：简化编译的过程，缩短时间并生成与硬件对应的正确的设备树文件 ","date":"2023-06-19","objectID":"/posts/petalinux/petalinux_1/:0:1","tags":["Petalinux","ZYNQ","NFS"],"title":"Petalinux(一)：安装使用","uri":"/posts/petalinux/petalinux_1/"},{"categories":["Embedded System"],"content":"petalinux 的安装 petalinux 对操作系统版本和依赖版本要求很高，只能在官方文档指定的发行版安装。这里以 petalinux 2017.04 为例 OS: ubuntu16.04(docker x86-64) Dependencies: sudo dpkg --add-architecture i386 sudo apt install libssl-dev flex bison chrpath socat autoconf libtool texinfo gcc-multilib libsdl1.2-dev libglib2.0-dev screen pax net-tools wget diffstat xterm gawk xvfb git make libncurse5-dev tftpd zlib1g libssl-dev gnupg tar unzip build-essential libtool-bin dialog cpio lsb-release zlib1g:i386 zlib1g-dev:i386 locales openjdk-8-jdk sudo dpkg-reconfigure locales export LANG=en_US.UTF-8 由于 Petalinux 依赖发行版版本，推荐采用 Docker 环境安装。请查看 Petalinux 2017.04 Docker 环境 ","date":"2023-06-19","objectID":"/posts/petalinux/petalinux_1/:0:2","tags":["Petalinux","ZYNQ","NFS"],"title":"Petalinux(一)：安装使用","uri":"/posts/petalinux/petalinux_1/"},{"categories":["Embedded System"],"content":"petalinux 的使用 创建一个 ZYNQ 的工程模板： petalinux-create --type project --template zynq --name petalinux 读取分析硬件所使用的开发版型号来配置： petalinux-config --get-hw-description /mnt/linux_base.sdk 配置内核和根文件系统： petalinux-config -c kernel petalinux-config -c rootfs 开始编译： petalinux-build 将编译好的工程打包输出： petalinux-package --boot --fsbl ./images/linux/zynq_fsbl.elf --fpga --u-boot --force 使用 qemu 虚拟化平台对产生的 BootLoader 和 linux 内核进行测试（可选） petalinux-boot --qemu --prebuilt 3 将输出的文件移动到开发板启动，或者使用 tftp 方式远程启动： image.ub: linux 的内核镜像，并且打包了设备树文件 plnx_arm-system.dtb, 在内存中运行的文件系统 ramdisk. # image.ub images { kernel@0 { description = \"Linux Kernel\"; data = /incbin/(\"zImage\"); type = \"kernel\"; arch = \"arm\"; os = \"linux\"; compression = \"none\"; load = \u003c0x8000\u003e; entry = \u003c0x8000\u003e; hash@1 { algo = \"sha1\"; }; }; fdt@0 { description = \"Flattened Device Tree blob\"; data = /incbin/(\"plnx_arm-system.dtb\"); type = \"flat_dt\"; arch = \"arm\"; compression = \"none\"; hash@1 { algo = \"sha1\"; }; }; ramdisk@0 { description = \"ramdisk\"; data = /incbin/(\"petalinux-user-image-plnx_arm.cpio.gz\"); type = \"ramdisk\"; arch = \"arm\"; os = \"linux\"; compression = \"none\"; hash@1 { algo = \"sha1\"; }; }; }; ","date":"2023-06-19","objectID":"/posts/petalinux/petalinux_1/:0:3","tags":["Petalinux","ZYNQ","NFS"],"title":"Petalinux(一)：安装使用","uri":"/posts/petalinux/petalinux_1/"},{"categories":["Embedded System"],"content":"petalinux 产生设备树的分析 使用 petalinux 的优势：自动分析硬件并产生设备树，也可以添加需要的部分并手动编译。 产生设备树的目录： $(project)/components/plnx_workspace/device-tree/device-tree-generation/ 设备树主要分两个部分： ARM CPU 相关的设备包括处理器内存，系统总线等等，在 zynq-7000.dtsi 中。（dtsi:设备树中描述 SOC 级的信息，一般不需要修改；dts: 设备树的源文件，修改设备树的主要对象；dtb: 由 dts 文件编译生成的二进制文件，由内核在启动时候读取并解析） petalinux 根据硬件的配置来生成 pl.dtsi 文件，文件内包括在根节点下的 FPGA 部分的设备树。 pl.dtsi 和 zynq-7000.dtsi 包含在 system-top.dts 内，手动添加的设备树也包含在内。 plnx_arm-system.dts 是处理了包含关系后的文件，编译生成 plnx_arm-system.dtb. pl.dtsi ---------| pcw.dtsi ---------|----\u003e system-top.dts ----\u003e plnx_arm-system.dts -----(dtc)----\u003e plnx_arm-system.dtb zynq-7000.dtsi ---| ","date":"2023-06-19","objectID":"/posts/petalinux/petalinux_1/:0:4","tags":["Petalinux","ZYNQ","NFS"],"title":"Petalinux(一)：安装使用","uri":"/posts/petalinux/petalinux_1/"},{"categories":["Embedded System"],"content":"实验：产生 GPIO 设备树文件，使用 Linux 内的 gpio 驱动程序，用文件 IO 方式驱动 led 系统描述：PS 和 PL 各有一个 led，通过 petalinux 产生一个完整 linux 系统，FPGA 端烧写一个 GPIO 控制器，输出 1 位信号到 R19 引脚，FPGA 的 R19 引脚连接了 pl 侧的 led 灯： set_property PACKAGE_PIN R19 [get_ports {gpio_out}] # R19引脚连接板上的led灯 set_property IOSTANDARD LVCMOS33 [get_ports {gpio_out}] linux 内核包含了 gpio 的驱动，可以根据设备树信息来自动检测硬件 $ cd /sys/class/gpio \u0026\u0026 ls export gpiochip906 gpiochip504 unexport # 访问/sys/class/gpio/目录，gpio906和gpio504分别是PS端和PL端的gpio控制器, export是内核提供的文件用于导出gpio的操作接口。 $ echo 906 \u003e export $ echo 504 \u003e export # 向export文件写入GPIO编号，就可以获得这个GPIO的操作接口。 $ ls export gpio906 gpiochip906 gpio504 gpiochip504 unexport # 新产生了gpio906和gpio504目录，目录中就是操作接口。 $ cd gpio906 \u0026\u0026 ls active_low direction power uevent device edge subsystem value # direction控制gpio的方向，value为gpio的输入输出值。 $ echo out \u003e direction $ echo 1 \u003e value # led灯灭 $ echo 0 \u003e value # led灯亮 # 通过一般的IO操作value这个文件就可以控制灯的亮灭。 产生的 GPIO 设备树部分(FPGA 侧): axi_gpio_0: gpio@41200000 { #gpio-cells = \u003c2\u003e; compatible = \"xlnx,xps-gpio-1.00.a\"; gpio-controller ; reg = \u003c0x41200000 0x10000\u003e; xlnx,all-inputs = \u003c0x0\u003e; xlnx,all-inputs-2 = \u003c0x0\u003e; xlnx,all-outputs = \u003c0x1\u003e; xlnx,all-outputs-2 = \u003c0x0\u003e; xlnx,dout-default = \u003c0x00000000\u003e; xlnx,dout-default-2 = \u003c0x00000000\u003e; xlnx,gpio-width = \u003c0x1\u003e; xlnx,gpio2-width = \u003c0x20\u003e; xlnx,interrupt-present = \u003c0x0\u003e; xlnx,is-dual = \u003c0x0\u003e; xlnx,tri-default = \u003c0xFFFFFFFF\u003e; xlnx,tri-default-2 = \u003c0xFFFFFFFF\u003e; }; ","date":"2023-06-19","objectID":"/posts/petalinux/petalinux_1/:0:5","tags":["Petalinux","ZYNQ","NFS"],"title":"Petalinux(一)：安装使用","uri":"/posts/petalinux/petalinux_1/"},{"categories":["Embedded System"],"content":"实验：直接将 FPGA 寄存器信号输出到 R19 引脚，通过 AXI-Lite 总线读写寄存器来控制 led 定义一个 32-bits 寄存器来接受总线信号，写入寄存器的值取一位输出到 led 灯 # 定义一个32位寄存器 reg [C_S_AXI_DATA_WIDTH-1:0] slv_reg0; # 将寄存器的第0位连接到输出信号 assign test_out = slv_reg0[0]; # 将总线模块打包，在test中调用AXI总线，添加一个输出信号test_out myip_v1_0_S00_AXI # ( .C_S_AXI_DATA_WIDTH(C_S00_AXI_DATA_WIDTH), .C_S_AXI_ADDR_WIDTH(C_S00_AXI_ADDR_WIDTH) ) myip_v1_0_S00_AXI_inst ( .S_AXI_ACLK(s00_axi_aclk), .S_AXI_ARESETN(s00_axi_aresetn), .S_AXI_AWADDR(s00_axi_awaddr), .S_AXI_AWPROT(s00_axi_awprot), .S_AXI_AWVALID(s00_axi_awvalid), .S_AXI_AWREADY(s00_axi_awready), .S_AXI_WDATA(s00_axi_wdata), .S_AXI_WSTRB(s00_axi_wstrb), .S_AXI_WVALID(s00_axi_wvalid), .S_AXI_WREADY(s00_axi_wready), .S_AXI_BRESP(s00_axi_bresp), .S_AXI_BVALID(s00_axi_bvalid), .S_AXI_BREADY(s00_axi_bready), .S_AXI_ARADDR(s00_axi_araddr), .S_AXI_ARPROT(s00_axi_arprot), .S_AXI_ARVALID(s00_axi_arvalid), .S_AXI_ARREADY(s00_axi_arready), .S_AXI_RDATA(s00_axi_rdata), .S_AXI_RRESP(s00_axi_rresp), .S_AXI_RVALID(s00_axi_rvalid), .S_AXI_RREADY(s00_axi_rready), .test_out(test_out) ); # 修改wrapper添加输出信号 output wire test_out # 绑定输出信号到led灯相连的引脚 set_property PACKAGE_PIN R19 [get_ports {test_out}] set_property IOSTANDARD LVCMOS33 [get_ports {test_out}] petalinux 根据系统硬件设计添加了 AXI-Lite 总线对应的设备树部分 # amba-axi总线的设备树部分 / { amba_pl: amba_pl { #address-cells = \u003c1\u003e; #size-cells = \u003c1\u003e; compatible = \"simple-bus\"; ranges ; myip_v1_0_0: myip_v1_0@43c00000 { # 寄存器的物理地址是0x43c00000 compatible = \"xlnx,myip-v1-0-1.0\"; reg = \u003c0x43c00000 0x10000\u003e; xlnx,s00-axi-addr-width = \u003c0x4\u003e; xlnx,s00-axi-data-width = \u003c0x20\u003e; }; }; }; 寄存器的物理地址是 0x43c00000，对这个地址的第一个字节的 0 位写值就可以控制 led 灯的亮灭 $ busybox devmem 0x43c00000 8 0x01 # 灯灭 $ busybox devmem 0x43c00000 8 0x00 # 灯亮 Q: 最小的寄存器组: 4 个(0x43c00000-0x43c0000f), 从 0x40000000-0x4fffffff 全部被映射到了最初的 16 个字节。 实际上被映射的物理内存区域有 1G，从地址 0x40000000-0x4fffffff ","date":"2023-06-19","objectID":"/posts/petalinux/petalinux_1/:0:6","tags":["Petalinux","ZYNQ","NFS"],"title":"Petalinux(一)：安装使用","uri":"/posts/petalinux/petalinux_1/"},{"categories":["Embedded System"],"content":"测试：从 Linux 端读写寄存器，寄存器连接一个宽度 16bit，深度 256 的 Block RAM，通过读写 3 个寄存器来实现对 Block RAM 的指定地址的读写。 由一个 TOP 模块，来例化了一个 AXI-Lite 总线接口，这个总线接口定义了 60 个寄存器并且引出。还有一个 BlockRAM 模块，将 AXI 总线定义的三个寄存器输入到 RAM 的控制接口里，然后通过对总线读写来控制 RAM。 AXI 总线模块： AXI_Lite axi_lite (.register00(AXI_Lite_register00), .register01(AXI_Lite_register01), .register02(AXI_Lite_register02), .register03(AXI_Lite_register03), .register04(AXI_Lite_register04), .register05(AXI_Lite_register05), .register06(AXI_Lite_register06), .register07(AXI_Lite_register07), .register08(AXI_Lite_register08), .register09(AXI_Lite_register09), .register10(AXI_Lite_register10), ...... 对 BlockRAM 的接口定义： bram_wrapper mappingRAM ( # 写地址：0x000-0x100(深度256) .BRAM_PORTA_0_addr(AXI_Lite_register01[7:0]), # 写时钟：FCLK_CLK0 .BRAM_PORTA_0_clk(s00_axi_aclk_0_1), # 写数据：16bit数据 .BRAM_PORTA_0_din(AXI_Lite_register02[15:0]), # PORTA使能 .BRAM_PORTA_0_en(1'b1), # PORTA写使能 .BRAM_PORTA_0_we(1'b1), # PORTB读地址 .BRAM_PORTB_0_addr(AXI_Lite_register03[7:0]), # PORTB读时钟 .BRAM_PORTB_0_clk(s00_axi_aclk_0_1), # PORTB读数据 .BRAM_PORTB_0_dout(w_ramout[15:0]), # PORTB读使能 .BRAM_PORTB_0_en(1'b1) ); ramout_0 -\u003e led(R19) # register ———————————————————— ————————————- | register01[7:0] | ————\u003e 写地址，输入到PORTA addr ——————\u003e | | ———————————————————— | register02[15:0] | ————\u003e 写数据，输入到PORTA din ——————\u003e | 256 x 16 | ———————————————————— | register03[7:0] | ————\u003e 读地址，输入到PORTB addr ——————\u003e | | ———————————————————— ————————————- | ramout[0] —————————————— | led \u003c———————————————————| ramout[15:0] |————————— —————————————— 测试过程: # 初始状态：ram内全部清零，ramout[0] 输出为0，\"led灯亮\" # 给RAM的写地址端口写入0x43c00004 $ busybox devmem 0x43c00004 8 0x55 # 给RAM的写数据端口写入16位数据0x0001 $ busybox devmem 0x43c00008 16 0x0001 此时RAM的0x55地址写入了数据 0000 0000 0000 0001 # 给0x43c0000c地址写入0x55，表示给RAM的读地址端口写0x55 $ busybox devmem 0x43c0000c 8 0x55 此时ramout的第0位由0变成了1，\"led灯灭\" # 把0x55的数据重新写为0 $ busybox devmem 0x43c00008 16 0x0000 \"led灯亮\" # 或者改变读地址的值 $ busybox devmem 0x43c0000c 8 0x56 \"led灯亮\" 上述实验证明数据写入 RAM 成功 ","date":"2023-06-19","objectID":"/posts/petalinux/petalinux_1/:0:7","tags":["Petalinux","ZYNQ","NFS"],"title":"Petalinux(一)：安装使用","uri":"/posts/petalinux/petalinux_1/"},{"categories":["Linux"],"content":"前言 安装Gentoo并不复杂，很多人混淆了复杂和耗时。在安装的过程中，大部分的时间都在做别的事情。同时，Gentoo的安装步骤是清晰的，Handbook和各路神仙的总结实际上已经很全面了。因此，没有必要再做重复的劳动，一些个性化的关键点记录就足够了。 为了使系统保持Suckless，尽量避免用不到的功能，我还是继续沿用裸wm的方式。简而言之：gentoo + openrc + i3wm + polybar + nvim。我的目标是尽量在一天内完成系统的整体安装，再用一周时间进行小修小补。而在流程化的步骤下，一天内的实际安装时间在1小时左右，而其余时间都在做其他事情。 此外，对于小新pro这种散热垃圾的Laptop，一个带风扇的散热架是必要的。否则，emerge -e @world 是真的会卡死（哭）。 ","date":"2023-06-18","objectID":"/posts/gentoo/gentoo%E5%AE%89%E8%A3%85%E5%B0%8F%E8%AE%B0/:1:0","tags":["Linux","Gentoo"],"title":"Gentoo安装小记","uri":"/posts/gentoo/gentoo%E5%AE%89%E8%A3%85%E5%B0%8F%E8%AE%B0/"},{"categories":["Linux"],"content":"安装步骤 Gentoo的安装大体上是规范的，但是针对不同用户的需求和理念，也有不一样的方式。或多或少的，存在一些坑 我在安装过程主要参考的几个链接： 官方Handbook，这是最权威的手册，当问题不确定时，以Handbook为准 Handbook 一篇较为详细的安装笔记，属于经验丰富的老玩家心得了，很有参考价值 Gentoo安装流程分享(step by step)，第一篇之基本系统的安装 OriPoin’s blog，详细介绍了Gentoo的优化方式，但是没必要采用O3，会带来很多未知问题 Emerge your world the lean way Optimize Your system the stupid way bitbili’s blog，非常非常详细的介绍了Gentoo的安装和使用 Gentoo Linux 安装及使用指南 Yangmame的安装教程 Gentoo安装教程 ayamir的知乎记录 2020-Gentoo双系统安装指北 Google，Stack Overflow，gentoo wiki，arch wiki等 ","date":"2023-06-18","objectID":"/posts/gentoo/gentoo%E5%AE%89%E8%A3%85%E5%B0%8F%E8%AE%B0/:2:0","tags":["Linux","Gentoo"],"title":"Gentoo安装小记","uri":"/posts/gentoo/gentoo%E5%AE%89%E8%A3%85%E5%B0%8F%E8%AE%B0/"},{"categories":["Linux"],"content":"make.conf make.conf可以说是Gentoo的核心了，针对PC的配置、优化以及对系统的预期基本上都是在这个文件中定义的，首先列出我的： # These settings were set by the catalyst build script that automatically # built this stage. # Please consult /usr/share/portage/config/make.conf.example for a more # detailed example. COMMON_FLAGS=\"-march=native -O2 -pipe\" CFLAGS=\"${COMMON_FLAGS}\" CXXFLAGS=\"${COMMON_FLAGS}\" FCFLAGS=\"${COMMON_FLAGS}\" FFLAGS=\"${COMMON_FLAGS}\" USE=\"X elogind mount cjk i3wm mpd network pulseaudio ipc opengl dbus -gnome -kde\" MAKEOPTS=\"-j6\" LC_MESSAGES=C EMERGE_DEFAULT_OPTS=\"--ask --verbose --load-average --newuse --with-bdeps=y --keep-going --deep\" CPU_FLAGS_X86=\"aes avx avx2 f16c fma3 mmx mmxext pclmul popcnt rdrand sse sse2 sse3 sse4_1 sse4_2 ssse3\" AUTO_CLEAN=\"yes\" PORTDIR=\"/var/db/repos/gentoo\" DISTDIR=\"/var/cache/distfiles\" PKGDIR=\"/var/chache/binpkgs\" PORTAGE_TMPDIR=\"/tmp\" PORTAGE_COMPRESS=\"zstd\" BINPKG_COMPRESS=\"zstd\" ACCEPT_LICENSE=\"*\" ACCEPT_KEYWORDS=\"~amd64\" GRUB_PLATFORMS=\"efi-64\" VIDEO_CARDS=\"nouveau\" GENTOO_MIRRORS=\"https://mirrors.tuna.tsinghua.edu.cn/gentoo\" MICROCODE_SIGNATURES=\"-S\" # NOTE: This stage was built with the bindist Use flag enabled # This sets the language of build output to English. # Please keep this setting intact when reporting bugs. LC_MESSAGES=C.utf8 # ccache FEATURES=\"ccache -test\" CCACHE_DIR=\"/var/cache/ccache\" # aria2 FETCHCOMMAND=\"/usr/bin/aria2c -d \\${DISTDIR} -o \\${FILE} --allow-overwrite=true --max-tries=5 --max-file-not-found=2 --max-concurrent-downloads=5 --connect-timeout=5 --timeout=5 --split=5 --min-split-size=2M --lowest-speed-limit=20K --max-connection-per-server=9 --uri-selector=feedback \\${URI}\" RESUMECOMMAND=\"${FETCHCOMMAND}\" ","date":"2023-06-18","objectID":"/posts/gentoo/gentoo%E5%AE%89%E8%A3%85%E5%B0%8F%E8%AE%B0/:3:0","tags":["Linux","Gentoo"],"title":"Gentoo安装小记","uri":"/posts/gentoo/gentoo%E5%AE%89%E8%A3%85%E5%B0%8F%E8%AE%B0/"},{"categories":["Linux"],"content":"问题列举 Gentoo默认是复杂密码，为了便于日常使用，改为简单密码： /etc/security/passwdqc.conf min=8,8,8,8,8 max=40 passphrase=0 match=4 similar=permit random=24 enforce=none retry=3 或者全局USE -pam，我还没有尝试 eudev还是systemd-utils？ Gentoo目前用systemd-utils替代了原本的eudev，所以解决办法有： 使用systemd-utils管理设备，不要再安装eudev，这是最简单的。官方的原话是：in general, you should not worry about installing anything *udev manually by yourself and you should imho not have anything like that in your world file. 如果你痛恨和systemd有关的一切，可以为systemd-utils包-udev USE，然后应该就可以安装eudev了。需要注意的是，eudev不应该被加入到world file中。此外还有一些其他的USE也会影响，总之这很麻烦。建议还是不要折腾了，systemd-utils只是从systemd中分离出来的组件而已，它包含了udev Desktop profiles？ Desktop profiles预设了很多USE，并包含了一些system依赖。对于KDE和GNOME用户，Desktop profiles中提供的增量可以省很多事。但是对于裸WM来说，没有必要为使用Desktop，默认的profiles或者systemd profiles就可以了。在最小化的基础上，安装软件时检查USE并逐步添加自己的全局USE ","date":"2023-06-18","objectID":"/posts/gentoo/gentoo%E5%AE%89%E8%A3%85%E5%B0%8F%E8%AE%B0/:4:0","tags":["Linux","Gentoo"],"title":"Gentoo安装小记","uri":"/posts/gentoo/gentoo%E5%AE%89%E8%A3%85%E5%B0%8F%E8%AE%B0/"},{"categories":null,"content":"个人经历 本科毕业于北京邮电大学自动化学院，博士毕业于中国科学院高能物理研究所。博士期间研究方向为粒子加速器控制技术和加速器定时系统 ","date":"0001-01-01","objectID":"/about/:1:0","tags":null,"title":"概况","uri":"/about/"},{"categories":null,"content":"研究兴趣 嵌入式 FPGA ZYNQ Kernel EPICS ","date":"0001-01-01","objectID":"/about/:2:0","tags":null,"title":"概况","uri":"/about/"}]