[{"categories":["C"],"content":"extern 告诉编译器，变量 i 是在程序中的其他位置定义的（很可能是在不同的源文件中），因此不需要为 i 分配空间 一个全局变量可以声明多次，但只能定义一次。只要在任意一个文件中只定义一次就可以了，其他文件中如果要使用需要先用 extern 声明。如果其他文件中没有使用 extern 声明，则会报重复定义的错误 注意：extern int a是声明而extern int a = 0是定义，要分清楚 在多文件的工程中，有如下几种用法（假设 A 包含源文件和头文件，B 和 C 包含源文件，B 和 C 要使用 A 中定义的变量 a）： A 的源文件中定义，B 和 C 的源文件中使用前先 extern，此时可以没有头文件 // A.c int a = 0; /* 可以赋值也可以不赋值 */ // B.c \u0026 C.c extern int a; /* 不可以直接 extern int a = 1，这相当于重复定义 */ a = 1; A 的源文件中定义，头文件中声明，B 和 C 通过包含 A 的头文件使用 // A.c int a = 0; /* 可以赋值也可以不赋值 */ // A.h extern int a; /* 不推荐直接在头文件中进行定义 extern int a = 0，别的文件包含后会重复定义 */ // B.c \u0026 C.c #include \"A.h\" a = 1; A 的源文件中未定义只声明，在 B 和 C 任意中定义 // A.c extern int a; /* A 中声明 */ // B.c int a = 0; /* B 中定义 */ // C.c extern int a = 0; /* C 中声明 */ 总之，C 语言的全局变量是所有文件均可见的，extern 只是告诉了编译器这个变量不是在该文件中定义的。在整个工程中，一个全局变量只能被定义一次，被声明和使用无数次。在非全局作用域下，可以定义同名的变量，这就涉及到作用域的问题 ","date":"2023-09-01","objectID":"/posts/c/extern/:0:0","tags":["C","Lang"],"title":"对 C 语言中 extern 的理解","uri":"/posts/c/extern/"},{"categories":["BIOS"],"content":"DXE Install BDS Protocol 在DXE阶段的Main中，调用CoreDispatcher() -\u003e CoreStartImage()，进入各DXE driver的入口函数: // MdeModulePkg/Core/Dxe/DxeMain/DxeMain.c Image-\u003eStatus = Image-\u003eEntryPoint (ImageHandle, Image-\u003eInfo.SystemTable); 此阶段会load并执行各DXE的驱动程序，而BDS就属于DXE的一个驱动，所以BdsInitialize()这个函数会在此时被执行： // MdeModulePkg/Universal/BdsDxe/BdsDxe.inf [Defines] INF_VERSION = 0x00010005 BASE_NAME = BdsDxe MODULE_UNI_FILE = BdsDxe.uni FILE_GUID = 6D33944A-EC75-4855-A54D-809C75241F6C MODULE_TYPE = DXE_DRIVER // BDS是DXE驱动 VERSION_STRING = 1.0 ENTRY_POINT = BdsInitialize // 驱动入口函数 入口函数BdsInitialize()调用InstallMultipleProtocolInterfaces()注册BdsArchProtocol到DXE Core，该Protocol的Guid为gEfiBdsArchProtocolGuid，*gBds是一个指向BdsArchProtocol的指针，在MdeModulePkg/Core/Dxe/DxeMain/DxeMain.c开始时定义： // `MdeModulePkg/Core/Dxe/DxeMain/DxeMain.c EFI_BDS_ARCH_PROTOCOL *gBds = NULL; 在BdsEntry.c中BDS初始化阶段BdsInitialize，*gBds指针作为InstallMultipleProtocolInterfaces()的参数，来将入口函数BdsEntry注册到PROTOCOL_INTERFACE中： // MdeModulePkg/Universal/BdsDxe/BdsEntry.c EFI_BDS_ARCH_PROTOCOL gBds = { BdsEntry }; // MdeModulePkg/Universal/BdsDxe/BdsEntry.c // Install protocol interface Handle = NULL; Status = gBS-\u003eInstallMultipleProtocolInterfaces ( \u0026Handle, \u0026gEfiBdsArchProtocolGuid, \u0026gBds, NULL ); 需要注意的是：在BdsEntry.c中的gBds只是为了注册，而在DxeMain()最后进入Bds阶段使用的指针是在别的地方赋值的。Dxe中有如下结构体： EFI_CORE_PROTOCOL_NOTIFY_ENTRY mArchProtocols[] = { { \u0026gEfiSecurityArchProtocolGuid, (VOID **)\u0026gSecurity, NULL, NULL, FALSE }, { \u0026gEfiCpuArchProtocolGuid, (VOID **)\u0026gCpu, NULL, NULL, FALSE }, { \u0026gEfiMetronomeArchProtocolGuid, (VOID **)\u0026gMetronome, NULL, NULL, FALSE }, { \u0026gEfiTimerArchProtocolGuid, (VOID **)\u0026gTimer, NULL, NULL, FALSE }, { \u0026gEfiBdsArchProtocolGuid, (VOID **)\u0026gBds, NULL, NULL, FALSE }, ... } 首先通过这个数组将*gBds和gEfiBdsArchProtocolGuid建立起联系，然后在Dxe阶段的Main函数中，通过CoreNotifyOnProtocolInstallation()-\u003eCoreNotifyOnProtocolEntryTable()创建事件(Event)，这里传入的Entry为mArchProtocols，最终由GenericProtocolNotify()函数给mArchProtocols的每一个成员赋值。这里，CoreCreatEvent()和CoreRegisterProtocolNotify成对出现，一旦Protocol安装则执行回调函数GenericProtocolNotify() /** Creates an event for each entry in a table that is fired everytime a Protocol of a specific type is installed. @param Entry Pointer to EFI_CORE_PROTOCOL_NOTIFY_ENTRY. **/ VOID CoreNotifyOnProtocolEntryTable ( EFI_CORE_PROTOCOL_NOTIFY_ENTRY *Entry ) { EFI_STATUS Status; for ( ; Entry-\u003eProtocolGuid != NULL; Entry++) { // // Create the event // Status = CoreCreateEvent ( EVT_NOTIFY_SIGNAL, TPL_CALLBACK, GenericProtocolNotify, Entry, \u0026Entry-\u003eEvent ); ASSERT_EFI_ERROR (Status); // // Register for protocol notifactions on this event // Status = CoreRegisterProtocolNotify ( Entry-\u003eProtocolGuid, Entry-\u003eEvent, \u0026Entry-\u003eRegistration ); ASSERT_EFI_ERROR (Status); } } 在回调函数GenericProtocolNotify中，Bds入口函数BdsEntry()被locate，然后被赋值给*gBds： // // See if the expected protocol is present in the handle database // Status = CoreLocateProtocol (Entry-\u003eProtocolGuid, Entry-\u003eRegistration, \u0026Protocol); if (EFI_ERROR (Status)) { return; } // Mark the protocol as present Entry-\u003ePresent = TRUE; // Update protocol global variable if one exists. Entry-\u003eProtocol points to a global variable // if one exists in the DXE core for this Architectural Protocol if (Entry-\u003eProtocol != NULL) { *(Entry-\u003eProtocol) = Protocol; } 最后，在Bds的入口函数已经被安装后，DxeMain()的最后通过*gBds指针进入Bds的入口BdsEntry()： gBds-\u003eEntry (gBds); 再讨论一下BDS的Protocol，EFI_BDS_ARCH_PROTOCOL是在Bds.h中定义的： // MdePkg/Include/Bds.h typedef struct _EFI_BDS_ARCH_PROTOCOL EFI_BDS_ARCH_PROTOCOL; typedef VOID (EFIAPI *EFI_BDS_ENTRY)( IN EFI_BDS_ARCH_PROTOCOL *This ); struct _EFI_BDS_ARCH_PROTOCOL { EFI_BDS_ENTRY Entry; }; 其中，EFI_BDS_ENTRY 就是这个protocol的一个服务，对应了一个PROTOCOL_INTERFACE。在之前的InstallMultipleProtocolInterfaces()函数中，Entry函数被指向EFI_BDS_ARCH_PROTOCOL这个Protocol的例化PROTOCOL_INTERFACE中的*Interface指针。所以根据Bds的Guid EFI_BDS_ARCH_PROTOCOL_GUID可以找到EFI_BDS_ARCH_PROTOCOL这个Protocol，再根据这个Protocol找到PROTOCOL_INTERFACE实现，就可以找到具体的被注册的BdsEntry()函数了 ","date":"2023-08-29","objectID":"/posts/bios/bds/:0:1","tags":["BIOS","EDK2","UEFI","AMI","X86"],"title":"UEFI BDS 阶段代码梳理","uri":"/posts/bios/bds/"},{"categories":["BIOS"],"content":" UEFI 并不是一个面向对象的系统，它是基于 C 语言的，C 语言是一种过程式语言。然而，UEFI 使用了一些设计模式和技术来模拟面向对象编程的某些特性，如封装、抽象和多态 封装：UEFI 使用结构体（struct）来封装数据和操作数据的函数。例如，每个 UEFI 协议都定义为一个结构体，其中包含一组函数指针，这些函数提供了协议的行为。这种方式类似于面向对象编程中的类和方法（Kernel 中也是类似） 抽象：UEFI 使用接口（协议）来定义可以由多个不同的实现提供的行为。这类似于面向对象编程中的接口或抽象类 多态：UEFI 通过使用函数指针和接口（协议）来实现多态。不同的驱动可以提供同一接口的不同实现，然后通过接口来调用这些函数，实现运行时的多态 继承：UEFI 并没有提供类似于面向对象编程中的继承机制。然而，它使用了一种叫做“装饰者”模式的设计模式，通过这种方式，一个驱动可以“装饰”另一个驱动，提供额外的功能，这在某种程度上模拟了继承的行为 ","date":"2023-08-08","objectID":"/posts/bios/uefi_1/:0:0","tags":["BIOS","UEFI","EDK2"],"title":"理解 UEFI 中的面向对象","uri":"/posts/bios/uefi_1/"},{"categories":["BIOS"],"content":"handle 和 protocol 的概念 UEFI 协议把访问设备的方法都抽象成了Handle和Protocol，Handle 是一个抽象的引用，用于引用一个或多个协议接口。一个设备便可以当成是一个 Handle（也可以当成是一个实例 Instance），而 Protocol 则是一个封装了某些操作方法的类（Class）。与面向对象有点区别的是，一个 Handle 可能是由多个 Protocols 组成的 Protocol 是一个由 struct 定义的结构体，这个结构体通常是由数据和函数指针组成。每个结构体的定义都有一个 GUID 与之对应。自然并不是所有的结构体都称之为 protocol，protocol 正如其名，它是一种规范，或称协议。比如要建立一个基于 UEFI Driver Model 的 Driver，就必须要绑定一个 EFI_DRIVER_BINGING_PROTOCOL 的实例，并且要自定义且实现 Support、Start、Stop 函数以及填充实例中其他的数据成员。再例如，EFI_SIMPLE_TEXT_INPUT_PROTOCOL 是一个协议，它定义了一组函数，这些函数可以用于从键盘读取输入 Handle 和 Protocol 都是通过双向链表组织的 定义的三个关键结构体： // MdeModulePkg/Core/Dxe/Hand/Handle.h /// /// IHANDLE - contains a list of protocol handles /// typedef struct { UINTN Signature; /// All handles list of IHANDLE LIST_ENTRY AllHandles; /// List of PROTOCOL_INTERFACE's for this handle LIST_ENTRY Protocols; UINTN LocateRequest; /// The Handle Database Key value when this handle was last created or modified UINT64 Key; } IHANDLE; /// /// PROTOCOL_ENTRY - each different protocol has 1 entry in the protocol /// database. Each handler that supports this protocol is listed, along /// with a list of registered notifies. /// typedef struct { UINTN Signature; /// Link Entry inserted to mProtocolDatabase LIST_ENTRY AllEntries; /// ID of the protocol EFI_GUID ProtocolID; /// All protocol interfaces LIST_ENTRY Protocols; /// Registerd notification handlers LIST_ENTRY Notify; } PROTOCOL_ENTRY; typedef struct { UINTN Signature; /// Link on IHANDLE.Protocols LIST_ENTRY Link; /// Back pointer IHANDLE *Handle; /// Link on PROTOCOL_ENTRY.Protocols LIST_ENTRY ByProtocol; /// The protocol ID PROTOCOL_ENTRY *Protocol; /// The interface value VOID *Interface; /// OPEN_PROTOCOL_DATA list LIST_ENTRY OpenList; UINTN OpenListCount; } PROTOCOL_INTERFACE; 要明白 IHANDLE 这个结构体，就要明白 LIST_ENTRY 是如何被使用的。LIST_ENTRY 定义如下： // MdeModulePkg/Include/LinkedList.h /// /// _LIST_ENTRY structure definition. /// struct _LIST_ENTRY { LIST_ENTRY *ForwardLink; LIST_ENTRY *BackLink; }; #define _LIST_ENTRY LIST_ENTRY 首先，上面的LIST_ENTRY 这个结构体用于实现双向链表。但是与一般的链表实现方式不一样，它纯粹是 LIST*ENTRY 这个成员的链接，而不用在乎这个成员所在的结构体。一般的链表要求结点之间的类型一致，而这种链表只要求结构体存在 EFI_LIST_ENTRY 这个成员就够了。比如说 IHANDLE *handle1,_handle2;初始化后，handle1-\u003eAllHandles-\u003eForwardLink=handle2-\u003eAllHandles; handle2-\u003eAllHandles-\u003eBackLink=handle1-\u003eAllHandles。这样 handle1 与 handle2 的 AllHandles 就链接到了一起。但是这样就只能进行 AllHandles 的遍历了，怎么样遍历 IHANLE 实例呢？。这时候就要用到_CR 宏，_CR 宏的定义如下：#define \\_CR(Record, TYPE, Field) ((TYPE _) ((CHAR8 _) (Record) - (CHAR8 _) \u0026(((TYPE \\_) 0)-\u003eField)))，这个宏可以通过结构体实例的成员访问到实例本身 IHANDLE 中的 AllHandles 成员用来链接 IHANDLE 实例。这个链表的头部是一个空结点，定义为：EFI_LIST_ENTRY gHandleList。一开始 gHandleList-\u003eForwardLink=gHandleList; gHandleList-\u003eBackLink=gHandleList。每次 IHANDLE 都从 gHandleList-\u003eBackLink 插入进来，这个链表是一个环形双向链表。每当 Driver 建立一个新的 EFI_HANDLE 的时候就会插入到这条链表中来，被称之为 Handle Database Driver 会为 handle 添加多个 protocol，这些实例也是链表的形式存在。PROTOCOL_INTERFACE 的 link 用于连接以 IHANDLE 为空头结点以 PPOTOCOL_INTERFACE 为后续结点的链表 具体而言：IHANDLE 结构体定义中，Protocols 是一个 LIST_ENTRY 类型的成员，它是一个双向链表。这个链表用于链接所有的 PROTOCOL_INTERFACE 实例。在这个链表中，每个节点都包含两个指针：ForwardLink 和 BackLink。ForwardLink 指向链表中的下一个节点，BackLink 指向链表中的上一个节点。这样，通过遍历这个链表，就可以访问到所有的 PROTOCOL_INTERFACE 实例 此外，PROTOCOL_ENTRY 结构体是用来管理和跟踪已注册的协议的。每个协议都有一个对应的 PROTOCOL_ENTRY 实例，这个实例包含了协议的标识符和一个链表，这个链表链接了所有安装了这个协议的协议接口。例如，假设我们有一个协议 EFI_SIMPLE_TEXT_INPUT_PROTOCOL，它的标识符是{0x387477c1, 0x69c7, 0x11d2, {0x8e, 0x39, 0x00, 0xa0, 0xc9, 0x69, 0x72, 0x3b}}。当这个协议被注册时，会创建一个 PROTOCOL_ENTRY 实例，这个实例的 ProtocolID 成员被设置为这个标识符，Protocols 链表被初始化为一个空链表。然后，当一个驱动程序安装了一个 EFI_SIMPLE_TEXT_INPUT_PROTOCOL 协议接口到一个句柄上时，这个协议接口的 PROTOCOL_INTERFACE 实例就会被添加到 Protocols 链表中。这样，通过遍历 Protocols 链表，就可以找到所有安装了 EFI_SIMPLE_TEXT_INPUT_PROTOCOL 的协议接口 上述的标识符就是 GUID，每个协议接口都由一个全局唯一标识符（GUID）来标识。当一个驱动程序或应用程序想要使用一个特定的协议接口时，它需要通过 GUID 来查找这个协议接口。这个过程通常是通过调用 LocateProtocol 或 OpenProtocol 这样的 UEFI 服务来完成的。例如，如果一个驱动程序想要使用 EFI_SIMPLE_TEXT_INPUT_PROTOCOL（这是一个用于从键盘读取输入的协议），它需要先获取这个协议的 GUID，然后调用 LocateProtocol 函数，传入这个 GUID 作为参数。如果成功，LocateProtocol 函数会返回一个指向 EFI_SIMPLE_TEXT_INPUT_PROTOCOL 接口的指针，然后驱动程序就可以通过这个指针来调用协议的函数。这","date":"2023-08-08","objectID":"/posts/bios/uefi_1/:1:0","tags":["BIOS","UEFI","EDK2"],"title":"理解 UEFI 中的面向对象","uri":"/posts/bios/uefi_1/"},{"categories":["BIOS"],"content":"本篇文章详细完整的讨论现代处理器 boot 的过程，主要面向对象为 Intel、AMD 的 X86 架构和大部分 ARM 处理器架构 前置概念 CPU 的引脚宝贵，只能用来连接高速设备（包括 Memory 和 PCIE 设备），原本通过北桥芯片来连接。但是目前，北桥芯片（用来连接内存和高速 PCIE）已经被集成进 CPU 中 低速的 IO（USB、SATA、eSPI 等）和其余的 PCIE 设备，不会直连 CPU 的，而是通过南桥芯片（PCH）来连接。PCH 是一块 IO 密集型芯片，BMC 芯片和 BIOS 芯片也是连接在 PCH 上的。然后 PCH 通过高速串行的总线 DMI 来和 CPU 连接，这样的目的是节约 CPU 的引脚（本质上是引脚复用） ","date":"2023-08-04","objectID":"/posts/bios/boot/:0:0","tags":["BIOS","UEFI","X86","Boot","EDK2"],"title":"Boot 过程分析","uri":"/posts/bios/boot/"},{"categories":["BIOS"],"content":"After CPU 加电或 Reset 后，到 BIOS 执行之前的阶段 ","date":"2023-08-04","objectID":"/posts/bios/boot/:1:0","tags":["BIOS","UEFI","X86","Boot","EDK2"],"title":"Boot 过程分析","uri":"/posts/bios/boot/"},{"categories":["BIOS"],"content":"1. CPU 自检 CPU 进行自身硬件初始化。初始化完成后，CPU 被设置为实地址模式，地址无分页。所有寄存器被初始化为特定的值， Cache、TLB（Translation Lookup Table）、BLB（Branch Target Buffer）这三个部件的内容被清空（Invalidate） ","date":"2023-08-04","objectID":"/posts/bios/boot/:1:1","tags":["BIOS","UEFI","X86","Boot","EDK2"],"title":"Boot 过程分析","uri":"/posts/bios/boot/"},{"categories":["BIOS"],"content":"2. 设置 CPU 寄存器 寄存器 EIP（Instruction Pointer）、CS（Code Segment）被设置为 0x0000FFF0 和 0xFFFF0000。在实地址模式下（寄存器字长为 16 位），指令的物理地址是 CS « 4 + EIP。CPU 根据硬件设计，计算出第一条指令的地址：0xFFFF0000+0xFFF0 = 0xFFFFFFF0。随后，CPU 会从这个地址取指令并执行，需要在这个地址存放 BIOS 的代码 ","date":"2023-08-04","objectID":"/posts/bios/boot/:1:2","tags":["BIOS","UEFI","X86","Boot","EDK2"],"title":"Boot 过程分析","uri":"/posts/bios/boot/"},{"categories":["BIOS"],"content":"3. Load BIOS 现在的问题是：在上电启动后，CPU 外围设备包括内存初始化还没有进行，没有内存可供使用，虽然有可以直接使用 Cache 替代内存的方法(Cache As RAM，CAR)，但总是没有直接用起来方便 但是，BIOS 代码是存放在一块 NOR Flash 中的，这块 Flash 在主板上通过 SPI 总线与 PCH 相连。NOR Flash 和我们用在 SSD 里面的 Flash 一个显著的不同就是它是字节寻址的，而不是块寻址。这就意味着它可以 XIP（eXecute in place），直接执行代码而不需要先 copy 到内存中 随后，CPU 去寻址 0xFFFFFFF0，PCH 的 SPI 总线默认 decode 该地址，从 Flash 芯片取指令；SPI 控制器响应 Flash 并返回内容给 DMI 总线（连接 PCH 和 CPU 的总线）；DMI 总线将指令给 CPU，开始解码执行。随后，通过这种方式一点一点 decode 运行，这个过程通常又称为 shadow ","date":"2023-08-04","objectID":"/posts/bios/boot/:1:3","tags":["BIOS","UEFI","X86","Boot","EDK2"],"title":"Boot 过程分析","uri":"/posts/bios/boot/"},{"categories":["BIOS"],"content":"After BIOS 被启动 在此之前，需要先明确什么是 BIOS？以及目前的 BIOS 是什么架构？ 需要明确的是，启动 OS 并不一定需要使用 BIOS，我们常见的嵌入式设备（arm），它们使用 BootLoader 来引导 OS（一般是指 Linux），BootLoader 相当于 BIOS 的角色，负责初始化内存，加载 OS 内核等。由于嵌入式设备的硬件环境各不相同，没有统一的标准，所以在不同嵌入式硬件上运行 OS 每次都得修改配置 BootLoader 和内核，比较繁琐 BIOS 存在的条件是统一的硬件，像嵌入式这种就完全没有必要了。传统的 PC 设备和服务器则不一样，整个硬件系统架构都是有标准的，早期由 Intel，IBM，AMD 等大厂制定，发展至今已成为一套成熟且统一的系统架构。同样的，既然硬件能统一，OS 也可以做到一致。此时，要让 OS 可以在硬件工作起来，还需要一段引导程序，负责检初始化硬件（如初始化内存），检测硬件资源（如可否正常分配资源）等，前面这些都正常了，说明 OS 正常运行的条件满足了，此时做最后一步就是引导启动 OS 了，这一阶段的程序就称为 BIOS。BIOS 就是分级的配置各种硬件寄存器，Load Kernel, 启动 Boot Manager。这个过程是很复杂的，OS Loader 然后把控制权交接给 Kernel。最后，退居幕后给 Kernel 提供运行时服务 目前的 BIOS 采用 UEFI 标准设计，是一个简易的小操作系统，在完成主线任务的同时，也提供 UI、Shell 等方便交互的程序 早期以汇编为主的 BIOS 经过发展被目前的 UEFI BIOS 所替代。要了解 UEFI，还需要明确下面的概念： 首先，UEFI 只是一个规范，没有具体的实现。就目前而言，BIOS 就是指 UEFI，UEFI 就是 BIOS，不需要再进行区分。UEFI 是 Intel 及其小弟联合的规范，后来分为 UEFI 和 PI 两个部分，PI 后面再说。UEFI 侧重于和操作系统的接口，纯粹地是一个接口规范，它不会具体涉及平台固件是如何实现的。对于一台计算机，UEFI 固件提供服务，grub 这类 OS Loader 依赖于 UEFI 固件提供的接口来启动 Linux 内核。UEFI 是一套规范，阐述了 UEFI 需要实现哪些功能，这些功能该怎么实现，实现的时候需要使用什么名称。比如规范中有一个 USB 相关的定义，有一个 USB Host Controller Protocol，用来控制 USB 控制器，这个 Protocol 需要由 13 个函数组，每个函数都有详细注明了它的使用方法，传入传出参数，返回值等，但是具体函数内部具体如何实现是不做要求的，只要能实现对应的功能即可: typedef struct _EFI_USB2_HC_PROTOCOL { EFI_USB2_HC_PROTOCOL_GET_CAPABILITY GetCapability; EFI_USB2_HC_PROTOCOL_RESET Reset; EFI_USB2_HC_PROTOCOL_GET_STATE GetState; EFI_USB2_HC_PROTOCOL_SET_STATE SetState; EFI_USB2_HC_PROTOCOL_CONTROL_TRANSFER ControlTransfer; EFI_USB2_HC_PROTOCOL_BULK_TRANSFER BulkTransfer; EFI_USB2_HC_PROTOCOL_ASYNC_INTERRUPT_TRANSFER AsyncInterruptTransfer; EFI_USB2_HC_PROTOCOL_ASYNC_INTERRUPT_TRANSFER SyncInterruptTransfer; EFI_USB2_HC_PROTOCOL_ISOCHRONOUS_TRANSFER IsochronousTransfer; EFI_USB2_HC_PROTOCOL_ASYNC_ISOCHRONOUS_TRANSFER AsyncIsochronousTransfer; EFI_USB2_HC_PROTOCOL_GET_ROOTHUB_PORT_STATUS GetRootHubPortStatus; EFI_USB2_HC_PROTOCOL_SET_ROOTHUB_PORT_FEATURE SetRootHubPortFeature; EFI_USB2_HC_PROTOCOL_CLEAR_ROOTHUB_PORT_FEATURE ClearRootHubPortFeature UINT16 MajorRevision; UINT16 MinorRevision; } EFI_USB2_HC_PROTOCOL; UEFI 是标准，是给别人用的。UEFI 的使用者包括但不仅限于操作系统加载器（OS Loader），安装程序（installers），来自引导设备的 ROM（adapter ROMS），操作系统的预诊断程序（pre-OS diagnostics），工具（utilities）以及操作系统运行时服务（OS runtimes-services）。通常，UEFI 是关于如何进行引导过程的。引导就是一个将控制权限连续，逐级地移交，从而启动整个 OS 的过程，这就是 OS Loader 所肩负的职责 UEFI 的规范可以当做是一套库函数，是用来被调用的，那要怎么去使用这些库呢？整套引导的代码该从哪里写起？这时候一份称为《Platform Initialization Specification》（简称 PI Spec）的手册派上用场了 PI （Platform Initialization）规定了如何实现一个 UEFI 环境，是另一个规范，从 UEFI 分离出来的。PI 描述了从平台重启直到构建出 UEFI 兼容环境所需的完整过程。“如何实现”这一内容是 PI 要解决的问题。与 UEFI 的开放不同，PI 对 pre-OS 引导程序，OS，以及他们的加载器，在极大程度上是无关的，因为 PI 中有太多与这些 UEFI 使用者无关的平台构造方面的程序。PI 描述了从平台重启直到构建出 UEFI 兼容环境所需的完整过程。PI 手册定义了 UEFI 代码的各个启动阶段（除了 SEC 阶段）的流程，每个阶段需要做哪些操作。此外，还定义了启动过程中使用到的一些机制，如 HOB，SMM，S3 Resume 等 基于以上的规范，UEFI 代码 EDK 便可以实现了，目前最新的代码已经更名为 EDK2，是目前所有 UEFI 固件的基础代码 EDK2 主要是实现手册所定义的各项基本功能，是一套通用的代码，并不能直接拿来使用，还需要根据各个平台的差异做修改或对功能进行扩充，此时就有了做这项工作 UEFI 代码厂商，他们会整合优化 EDK2 的基础代码和芯片厂商（Intel、AMD 还有中国的龙芯，兆芯等）的核心代码，有些还会加进一些自家的特色功能，让代码使用起来更加便捷。AMI 就是比较著名的厂家，他们的代码都进行了深度的定制，很多功能几乎只要改改 enable 跟 disable 就可以了 在了解了基本概念后，开始分析 BIOS 的执行 ","date":"2023-08-04","objectID":"/posts/bios/boot/:2:0","tags":["BIOS","UEFI","X86","Boot","EDK2"],"title":"Boot 过程分析","uri":"/posts/bios/boot/"},{"categories":["BIOS"],"content":"BIOS 进入 待续 ","date":"2023-08-04","objectID":"/posts/bios/boot/:2:1","tags":["BIOS","UEFI","X86","Boot","EDK2"],"title":"Boot 过程分析","uri":"/posts/bios/boot/"},{"categories":["Embedded EVR"],"content":" 之前的两篇文章介绍了 Petalinux 的安装和远程启动，本手册是系列的第三篇文章。本篇以 Embedded EVR 为例，详细介绍从 FPGA 代码的综合、布局布线、生成 bit 流，到使用 Petalinux 创建工程、配置、编译和部署的过程 前提条件：一台可以联网的服务器，并且已经安装好 Vivado 软件 ","date":"2023-07-01","objectID":"/posts/embedeedevr/petalinux/petalinux_3/:0:0","tags":["Petalinux","ZYNQ"],"title":"Petalinux(三)：完全使用手册","uri":"/posts/embedeedevr/petalinux/petalinux_3/"},{"categories":["Embedded EVR"],"content":"前言 博士期间，我主要利用 timing4(192.168.206.186) 服务器完成嵌入式 EVR 的研究，其中涉及到 FPGA 开发和嵌入式 Linux 系统。嵌入式系统的开发往往具有步骤复杂、过程繁琐的特点，Petalinux 这类自动化的软件工具大大简化了开发步骤 在 Docker 环境中使用 Petalinux 的原因，已经在系列第一篇文章中介绍了。本手册按照如下的步骤来介绍 Petalinux 的使用： 在 timing4 上生成嵌入式 EVR 的 bit 流文件 导出嵌入式 EVR 的硬件描述文件到 Petalinux 容器中 制作 Petalinux 镜像，以 2017.04 为例 使用 Petalinux 镜像创建容器 启动容器，创建 Petalinux 工程 修改或添加所需的设备树 根据硬件描述文件配置 Petalinux 配置 Linux 内核、U-Boot 和根文件系统 编译整个 Petalinux 工程 打包并整理内核、U-Boot 和根文件系统等镜像 使用镜像文件制作可启动的 TF 卡 容器使用中可能遇到的问题 在遇到不可解决的问题时，恢复 Docker 环境 ","date":"2023-07-01","objectID":"/posts/embedeedevr/petalinux/petalinux_3/:1:0","tags":["Petalinux","ZYNQ"],"title":"Petalinux(三)：完全使用手册","uri":"/posts/embedeedevr/petalinux/petalinux_3/"},{"categories":["Embedded EVR"],"content":"内容 ","date":"2023-07-01","objectID":"/posts/embedeedevr/petalinux/petalinux_3/:2:0","tags":["Petalinux","ZYNQ"],"title":"Petalinux(三)：完全使用手册","uri":"/posts/embedeedevr/petalinux/petalinux_3/"},{"categories":["Embedded EVR"],"content":"在 timing4 上生成嵌入式 EVR 的 bit 流文件 1. 登录到 timing4 服务器的图形界面 由于我们需要使用 Vivado 工具，所以需要登录图形界面。登录 timing4 服务器的图形化界面有两种方式： 使用 xrdp 协议 timing4 服务器安装了 xrdp 服务器，可以直接使用 windows 自带的远程桌面，登录 192.168.206.186.用户名使用自己的用户名，随后会提示输入密码 使用 rustdesk timing4 服务器上安装了 rustdesk Server，远程登录需要在 timing4 上安装运行 rustdesk Client，并且在自己的电脑上也安装好 rustdesk Client。具体的操作步骤请参考rustdesk 使用手册 上述两种方式各有优劣，方式 1 不需要安装额外客户端软件，方式 2 具有文件传输等更丰富便捷的功能 2. 启动 Vivado timing4 上的 Vivado 安装在目录/opt/Xilinx/Vivado/2017.4下，在这个目录下存在 setting64.sh 文件，其中配置了 Vivado 所需的一些环境变量以及 PATH 变量。建议在启动 Vivado 之前先执行source /opt/Xilinx/Vivado/2017.4/setting64.sh，也可以将这个命令添加进用户自己的.bashrc 或者.zshrc 中。.zshrc 中的环境变量可以参考/home/zhangzh/.zshrc 在终端中执行 vivado 命令，即可打开 Vivado 的图形化界面，此后的操作和 Windows 下一致： 3. 在 Vivado 中综合并布线嵌入式 EVR 嵌入式 EVR 的代码放在目录/home/zhangzh/Lab/vivado中，其中 test9 为 EVR 功能模块的代码，打包为自定义 IP，放在/home/zhangzh/Lab/vivado/test9/test9.ip_user_files目录下。test9_wizard 为自定义 IP 和 ZYNQ IP 的连线工程，其主要内容为 Block Design 和约束文件 如果没有修改代码的需要，则只需打开 test9_wizard 工程。在下图 1 的位置有生成 bit 流的按钮，将按顺序自动的运行综合，布局布线，最后产生 bit 流。一杯咖啡后，右上角显示wirte_bitstream Complete √即表示运行成功。布线后生成的 bit 流文件为/home/zhangzh/Lab/vivado/test9_wizard/test9_wizard.runs/impl_1/design_1_wrapper.bit。这个文件可以通过 JTAG 的方式直接烧写进 FPGA 中，但无法被 U-Boot 或 xdevcfg 烧写。还需要使用 bootgen 工具将其转换为 BIN 文件格式 4. 将硬件描述文件导出 为什么上一步已经得到了嵌入式 EVR 的 bit 流，还需要将硬件描述文件导出？这是因为硬件描述文件(.hdf)描述了完整的硬件信息，包括 FPGA 中使用的资源，这些信息正是 Petalinux 所需要的。需要注意的是，在 Vivado 的高版本中，hdf 文件已经被 xsa 文件替代 此时，FPGA 部分的工作就可以结束了，Petalinux 随后会根据硬件描述文件中提供的信息去配置工程，或者从 Vivado 工程中将 bit 流文件拷贝出来。在 Petalinux 最终生成的镜像文件中，同样也包含 bit 流文件 ","date":"2023-07-01","objectID":"/posts/embedeedevr/petalinux/petalinux_3/:2:1","tags":["Petalinux","ZYNQ"],"title":"Petalinux(三)：完全使用手册","uri":"/posts/embedeedevr/petalinux/petalinux_3/"},{"categories":["Embedded EVR"],"content":"制作 Petalinux 镜像 本节以 2017.04 版本为例，介绍如何在 timing4 上制作 Petalinux 镜像 创建 Dockerfile 文件 $ touch Dockerfile # 将以下内容写入 Dockerfile $ cat Dockerfile FROM ubuntu:16.04 RUN dpkg --add-architecture i386 RUN apt update \\ \u0026\u0026 apt install -y sudo libssl-dev flex bison chrpath socat autoconf libtool texinfo gcc-multilib libsdl1.2-dev libglib2.0-dev screen pax net-tools wget diffstat xterm gawk xvfb git make libncurses5-dev tftpd zlib1g libssl-dev gnupg tar unzip build-essential libtool-bin dialog cpio lsb-release zlib1g:i386 zlib1g-dev:i386 locales openjdk-8-jdk\" # build 镜像 $ docker build -t \u003cimage_name\u003e . 使用 docker images 命令来管理镜像。latest 为默认的镜像 tag ","date":"2023-07-01","objectID":"/posts/embedeedevr/petalinux/petalinux_3/:2:2","tags":["Petalinux","ZYNQ"],"title":"Petalinux(三)：完全使用手册","uri":"/posts/embedeedevr/petalinux/petalinux_3/"},{"categories":["Embedded EVR"],"content":"使用 Petalinux 镜像创建容器 获得镜像后，创建一个容器 # 使用镜像创建容器 $ docker run -it --name \u003cname\u003e -v \u003cdir:dir\u003e --user root \u003cimage_name\u003e /bin/bash # 使用 docker exec 命令启动 docker $ docker start name $ docker exec --user root -it \u003cname\u003e /bin/bash 进入容器后，在容器中继续执行安装 # 添加普通用户 $ adduser \u003cuser_name\u003e # 修改 /etc/sudoers 文件，添加 sudo 权限 # 用普通用户身份启动 docker $ docker exec --user \u003cuser_name\u003e -it \u003cname\u003e /bin/bash # 配置安装 locales， 使用 en_US.UTF-8 $ sudo dpkg-reconfigure locales # 设置 LANG 环境变量为 en_US.UTF-8 $ export LANG=\"en_US.UTF-8\" # 从共享目录中将 Petalinux 安装镜像 copy 到容器中 $ cp /mnt/petalinux/petalinux-v2017.4-final-installer.run ~ # 执行安装，lisence 输入 yes $ ./petalinux-v2017.4-final-installer.run dir # 安装完成后，source Petalinux 的安装目录中的 setting.sh # petalinux 开头的命令可以使用 $ petalinux-xxx 使用 docker ps -a 查看所有的容器 其中 petalinux_image 创建了 2 个容器，这两个容器是相关不关联的 注意：mzz2017/v2raya 镜像和 v2ray 容器是 timing4 服务器上的系统代理，用于访问外网。在浏览器中输入localhost:2017，管理代理的节点 ","date":"2023-07-01","objectID":"/posts/embedeedevr/petalinux/petalinux_3/:2:3","tags":["Petalinux","ZYNQ"],"title":"Petalinux(三)：完全使用手册","uri":"/posts/embedeedevr/petalinux/petalinux_3/"},{"categories":["Embedded EVR"],"content":"进入容器 此时 petalinux_20220621 容器已被成功创建 timing4 每次重启后，都需要运行docker start petalinux_20220621来启动容器。然后使用docker exec --user zhangzh -it petalinux_20220621 /bin/bash 命令来进入容器，--user后应为自己在容器中新建的用户。使用 exit 退出容器，此时容器没有关闭，下次仍然使用docker exec命令进入 需要注意的是：Petalinux 不支持除了 bash 以外的其他 shell 为了方便每次 source Petalinux 的安装目录中的 setting.sh，可以在自己的目录下的.bashrc文件中添加如下内容： $ tail -3 .bashrc export LANG=\"en_US.UTF-8\" cd $HOME source /xxx/settings.sh ","date":"2023-07-01","objectID":"/posts/embedeedevr/petalinux/petalinux_3/:2:4","tags":["Petalinux","ZYNQ"],"title":"Petalinux(三)：完全使用手册","uri":"/posts/embedeedevr/petalinux/petalinux_3/"},{"categories":["Embedded EVR"],"content":"创建 Petalinux 工程 进入 Petalinux 环境后，在普通用户下新建工程目录，然后使用petalinux-creat创建一个工程 $ petalinux-create --type \u003cproject_type\u003e --template zynq --name xxx 这里的 type 是创建的类型，有三种类型： project: petalinux 标准的工程 apps: linux 用户态应用程序，首先创建好 project，在到工程目录下使用petalinux-create -t apps --template install --name \u003capp-name\u003e --enable命令创建一个应用。--template可以选择 c、c++等模板。然后将应用程序代码拷贝到components/apps/\u003capp-name\u003e/src目录下，应用程序就可以被 Petalinux 编译并包含在根文件系统镜像中 modules: linux 内核态模块，用于在 Petalinux 环境下编写内核模块代码，编写的内核模块会被包含在根文件系统镜像中 在嵌入式 EVR 中，只需要创建 project，应用程序 EPICS 不通过 Petalinux 来编译 $ petalinux-create --type project --template zynq --name embedded_evr 此时，一个 Petalinux 工程就被创建完毕了。此时目录中只有config.project文件和project-spec目录 ","date":"2023-07-01","objectID":"/posts/embedeedevr/petalinux/petalinux_3/:2:5","tags":["Petalinux","ZYNQ"],"title":"Petalinux(三)：完全使用手册","uri":"/posts/embedeedevr/petalinux/petalinux_3/"},{"categories":["Embedded EVR"],"content":"添加设备树节点 在工程创建好以后，我们先不导入硬件配置，而要添加我们需要的代码。对于嵌入式 EVR，FPGA 部分相当于 Linux 的设备，所以需要添加一个挂在 AXI 总线上的节点 ZYNQ 本身带了一些设备树文件，Petalinux 会默认包含并编译这部分设备树文件。这些设备树文件用于 PS 部分一些标准的系统和 FPGA 部分的官方 IP。对于嵌入式 EVR 这种自定义的设备，就需要添加新的设备树。Petalinux 中添加设备树不需要修改 ZYNQ 的设备树代码，而是在目录/home/zhangzh/workspace/embedded_evr/project-spec/meta-user/recipes-bsp/device-tree/files下的system-user.dtsi文件中进行修改 # 添加如下内容 /include/ \"system-conf.dtsi\" / { amba_pl: amba_pl { #address-cells = \u003c1\u003e; #size-cells = \u003c1\u003e; compatible = \"simple-bus\"; ranges ; uio_dev@43c00000 { compatible = \"generic-uio\"; interrupt-controller; interrupt-parent = \u003c\u0026intc\u003e; interrupts = \u003c0x0 0x1d 0x1\u003e; reg = \u003c0x43c00000 0x10000\u003e; }; }; }; 为了让内核匹配设备驱动程序，还需要修改内核启动参数，将generic-uio标识符传入内核。通常有两种方式，可以在petalinux config后或者直接在上述文件中添加 bootargs 变量 # 添加内核启动参数 chosen { bootargs = \"console=ttyPS0,115200 earlyprintk uio_pdrv_genirq.of_id=generic-uio root=/dev/mmcblk0p2 rw rootwait\"; stdout-path = \"serial0:115200n8\"; }; 在设备树中添加的内核参数会被 U-Boot 程序读取，并设置 U-Boot 的 bootargs 变量。其中，对于 ZYNQ console 的值为 ttyPS0，波特率取决于串口芯片。root 挂载的文件系统必须是 linux 系统支持的根文件系统设备名。uio_pdrv_genirq.of_id表示了uio_pdrv_genirq这个驱动程序匹配字符串，需要和设备树中的一致 另一种方式是petalinux-config后，在 tui 界面中找到user set bootargs并添加 ","date":"2023-07-01","objectID":"/posts/embedeedevr/petalinux/petalinux_3/:2:6","tags":["Petalinux","ZYNQ"],"title":"Petalinux(三)：完全使用手册","uri":"/posts/embedeedevr/petalinux/petalinux_3/"},{"categories":["Embedded EVR"],"content":"根据硬件描述文件配置 Petalinux 随后，执行如下命令，Petalinux 会从 vivado 工程中导入硬件描述文件，并自动完成硬件的相关配置 petalinux-config --get-hw-description /mnt/vivado/test9_wizard/test9_wizard.sdk 上述命令有几个需要注意的点： 容器内部的/mnt 目录也就是外部系统的共享目录。创建容器时，需要将/home/zhangzh/Lab目录和容器的/mnt目录共享。如果共享了别的目录，应该修改这里的路径，使 Petalinux 找到 vivado 工程的目录 嵌入式事件定时系统的 hdf 文件导出到了 test9_wizard 路径下 路劲需要写到 vivado 工程根目录下的 sdk 文件夹 命令执行期间会弹出 tui 界面进行配置 对于嵌入式事件定时系统，需要在此时更改上一节中所描述的内核启动参数 ","date":"2023-07-01","objectID":"/posts/embedeedevr/petalinux/petalinux_3/:2:7","tags":["Petalinux","ZYNQ"],"title":"Petalinux(三)：完全使用手册","uri":"/posts/embedeedevr/petalinux/petalinux_3/"},{"categories":["Embedded EVR"],"content":" 对于 Linux 远程启动是很普遍的，在 Petalinux 上配置远程启动很简单，并且 Petalinux 会自动配置 U-Boot 变量并增加内核启动参数 ","date":"2023-06-19","objectID":"/posts/embedeedevr/petalinux/petalinux_2/:0:0","tags":["Petalinux","ZYNQ","NFS"],"title":"Petalinux(二)：远程启动","uri":"/posts/embedeedevr/petalinux/petalinux_2/"},{"categories":["Embedded EVR"],"content":"1. 目标 内核文件通过 tftp 从 host 下载并启动，挂载的根文件系统为网络文件系统（nfs） 基本过程：BOOT.BIN 文件包括了硬件 bit 流、FSBL 和 U-Boot，这个文件放在板卡的 tf 卡或者 QSPI Flash 中，用于启动 Linux 内核。Linux 内核和设备树文件 image.ub 放在 host 上的 tftpboot 目录，U-Boot 通过 tftp 下载内核镜像到内存中，并启动内核。内核启动后，挂载 host 上的 nfs 文件系统作为根文件系统 ","date":"2023-06-19","objectID":"/posts/embedeedevr/petalinux/petalinux_2/:0:1","tags":["Petalinux","ZYNQ","NFS"],"title":"Petalinux(二)：远程启动","uri":"/posts/embedeedevr/petalinux/petalinux_2/"},{"categories":["Embedded EVR"],"content":"2. 组成：FSBL、U-Boot、kernel 和根文件系统 FSBL： 第二阶段引导文件，由 vivado 提供源码，用于在第一阶段引导代码（固定在芯片内的 rom 里）结束后，初始化一些 ZYNQ 常用的外设，由于是外部代码，可以根据需要自行修改 U-Boot： 第二阶段引导结束后将跳转执行 U-Boot，fsbl 没有远程拷贝的功能，所以 U-Boot 必须放置在板卡的可启动 ROM 内，主要为 TF 卡和 QSPI FLASH；U-Boot 具有板卡上大部分设备的驱动程序，可以配置网络，下载镜像并拷贝进内存中，最后跳转到内核的启动点 device tree： 设备树文件描述了硬件设备的信息，需要被 U-Boot 拷贝进内存并告诉内核地址，内核启动后读取设备树文件获取设备信息 Kernel： 内核镜像，有 uImage、zImage 等不同形式，具有不同的压缩方式与格式。U-Boot 支持各种形式的内核镜像，内核可以在本地部署也可以通过 tftp 或者 nfs 协议从 host 下载内核镜像，内核启动后初始化硬件并挂载根文件系统 根文件系统： 内核可以挂载本地 eMMC、TF 卡和远程 host 中的文件系统 ","date":"2023-06-19","objectID":"/posts/embedeedevr/petalinux/petalinux_2/:0:2","tags":["Petalinux","ZYNQ","NFS"],"title":"Petalinux(二)：远程启动","uri":"/posts/embedeedevr/petalinux/petalinux_2/"},{"categories":["Embedded EVR"],"content":"3. BOOT 所需文件的来源 FSBL： 由 VIVADO SDK 工具提供，使用 make 编译 U-Boot： 由官方发布源码，Xilinx 添加一些独有驱动，在 Github Xilinx 代码仓库维护，使用 make 编译 Kernel： Linux 内核源码，使用 make 编译 device tree： 由内核提供一部分，Xilinx 提供一部分，用户也可以自行添加，使用内核工具中的设备树专用编译器编译 根文件系统： 不同发行版针对不同体系结构有不同的根文件系统，目录结构固定，直接解压到被挂载的根目录，不需要编译 ","date":"2023-06-19","objectID":"/posts/embedeedevr/petalinux/petalinux_2/:0:3","tags":["Petalinux","ZYNQ","NFS"],"title":"Petalinux(二)：远程启动","uri":"/posts/embedeedevr/petalinux/petalinux_2/"},{"categories":["Embedded EVR"],"content":"各种文件的组织方式 由于最终都是将各种镜像拷贝进内存，被在每一阶段的最后跳转到下一阶段的执行点，所以理论上 BOOT 的过程可以将各种文件放置在不同的位置，或者相同位置下的不同文件 BOOT 文件的打包 FSBL、U-Boot、kernel、device tree 一起打包进 BOOT.BIN FSBL、U-Boot 打包进 BOOT.BIN，kernel 和 device tree 打包进 image.ub FSBL、U-Boot 打包进 BOOT.BIN，kernel 和 device tree 独立为 zImage 和 system.dtb 在 2 或 3 的基础上，BOOT.BIN 放在本地，kernel 和 device tree 放在远端，U-Boot 通过 tftp 协议从网络下载 kernel 和 device tree 在 2 或 3 的基础上，BOOT.BIN 放在本地，kernel 和 device tree 放在远端，U-Boot 通过 nfs 协议从网络下载 kernel 和 device tree 在 1、2、3、4、5 的基础上，BOOT.BIN 可以放在 tf 卡的第一分区或者 QSPI Flash 中 在 1、2、3、4、5、6 的基础上，根文件系统可以放在 tf 卡的非第一分区、eMMC 或通过 nfs 从网络挂载 ","date":"2023-06-19","objectID":"/posts/embedeedevr/petalinux/petalinux_2/:0:4","tags":["Petalinux","ZYNQ","NFS"],"title":"Petalinux(二)：远程启动","uri":"/posts/embedeedevr/petalinux/petalinux_2/"},{"categories":["Embedded EVR"],"content":"4. 使用手动编译生成可远程启动的镜像文件 使用手动编译 U-Boot 和 kernel 过程略 ","date":"2023-06-19","objectID":"/posts/embedeedevr/petalinux/petalinux_2/:1:0","tags":["Petalinux","ZYNQ","NFS"],"title":"Petalinux(二)：远程启动","uri":"/posts/embedeedevr/petalinux/petalinux_2/"},{"categories":["Embedded EVR"],"content":"配置 U-Boot 环境变量通过 tftp 启动 linux kernel 在 U-Boot 启动后，通过配置一些 U-Boot 环境变量来远程启动内核，这里假设内核和设备树文件放在 host 的/tftpboot 目录内 # 设置本机ip地址和host ip地址 zynq\u003e setenv ipaddr 192.168.206.187 zynq\u003e setenv serverip 192.168.206.187 # 将内核镜像zImage和设备树文件system.dtb通过tfpt下载进内存 # 将内核镜像下载到内存地址0x10000000 zynq\u003e tftpboot 10000000 zImage # 将设备树文件下载到内存地址 zynq\u003e tftpboot 10080000 system.dtb # 将地址传入bootz命令，启动zImage形式的内核 zynq\u003e bootz 10000000 - 10080000 由于手动编译设备树和内核文件分离，而挂载文件系统部分相似，后续挂载 nfs 见下一章节介绍 ","date":"2023-06-19","objectID":"/posts/embedeedevr/petalinux/petalinux_2/:1:1","tags":["Petalinux","ZYNQ","NFS"],"title":"Petalinux(二)：远程启动","uri":"/posts/embedeedevr/petalinux/petalinux_2/"},{"categories":["Embedded EVR"],"content":"5. 使用 petalinux 工具生成可远程启动镜像 在执行 petalinux-config 命令需要修改的部分 修改 U-Boot 配置 可以修改 netboot offset，即从远程下载镜像到内存中的地址偏移，远程 tftp server 的 IP 地址 修改镜像打包相关配置 build 整个系统 $ petalinux-build 将编译后的输出文件打包成适合部署的格式 # 一般 BOOT.BIN 包含 fsbl 文件、bitstream 和 U-Boot 文件 $ petalinux-package --boot --fsbl --fpga --u-boot --force 其余部分不需要修改，相关根文件系统挂载方式等等配置会生成相关内核参数，内核参数由 U-Boot 在启动时传递给内核 这里和之前手动编译生成启动镜像不同，没有下载设备树文件 system.dtb，原因是使用 petalinux 打包的内核镜像 image.ub 中是包含了设备树文件的。因为 image.ub 文件是通过 mkimage 命令制作的，是将内核镜像 zImage 和设备树 system.dtb 打包到一起 ","date":"2023-06-19","objectID":"/posts/embedeedevr/petalinux/petalinux_2/:1:2","tags":["Petalinux","ZYNQ","NFS"],"title":"Petalinux(二)：远程启动","uri":"/posts/embedeedevr/petalinux/petalinux_2/"},{"categories":["Embedded EVR"],"content":"6. 配置 U-Boot 启动 petalinux 编译的内核 基本步骤 基本步骤和手动编译启动内核一致，在远程 host 上需要具有 nfs 服务器，配置好 nfs 目录，并将根文件系统解压进该目录 在设置 IP 地址这一步，U-Boot 会先通过 DHCP 从 server 申请 IP 地址，如果 server 上有 DHCP 服务器，U-Boot 就会自动设置 ipaddr 这个环境变量，可以通过 printenv 打印出所有环境变量，serverip 这个环境变量是在 petalinux 配置阶段设置的 netboot 这个环境变量是 U-Boot 设置的，为 tfptboot ${netstart} ${kernel_img} \u0026\u0026 bootm, 其中 kernel_img 就是 image.ub 步骤： # 设置本机 ip 地址和 host ip 地址 zynq\u003e setenv ipaddr 192.168.138.2 zynq\u003e setenv servimagee通过 tfpt 下载进内存 # netboot 这个环境变量是 U-Boot 设置的，为 tfptboot ${netstart} ${kernel_img} \u0026\u0026 bootm, 其中 kernel_img 就是 image.ub zynq\u003e run netboot 配置默认启动命令 设置 U-Boot 默认命令，U-Boot 启动后会先配置网络，网络配置完成后就会进入倒计时，倒计时结束执行 bootcmd 中的命令，如果想自动 boot，只需要 zynq\u003e setenv bootcmd run netboot # 保存所有环境变量到 qspi zynq\u003e saveenv 配置内核参数环境变量 在设备树文件中有一个 chosen 字段，里面设置了内核参数变量 bootargs，U-Boot 中如果不手动配置这个变量，使用的是设备树文件中的内核参数，但是 U-Boot 中的 bootargs 环境变量具有最高优先级 ","date":"2023-06-19","objectID":"/posts/embedeedevr/petalinux/petalinux_2/:1:3","tags":["Petalinux","ZYNQ","NFS"],"title":"Petalinux(二)：远程启动","uri":"/posts/embedeedevr/petalinux/petalinux_2/"},{"categories":["Embedded EVR"],"content":"挂载 nfs 文件系统 决定根文件系统的方式主要是内核的启动参数，配置从 nfs 挂载，bootargs 应该被设置为 # petalinux会根据选项自动配置该变量 zynq\u003e setenv bootargs ‘console=ttyPS0,115200 root=/dev/nfs rw nfsroot=192.168.138.1:/home/zynq/linux/nfs/rootfs,tcp ip=dhcp’ 这个环境变量意义是，根文件系统使用 nfs 的方式以 rw 挂载，根文件系统目录在 192.168.138.1:/home/zynq/linux/nfs/rootfs，本机 ip 地址配置为 dhcp 方式从 server 获取 内核启动后会自动挂载 nfs 文件系统，如果挂载成功，内核就会启动完成 在挂载 nfs 时遇到问题：内核启动报错 VFS: Unable to mount root fs via NFS, trying floppy. VFS: Cannot open root device \"nfs\" or unknown-block(2,0): error -6 不能成功挂载的原因 防火墙问题 $ ufw disable 由于 nfs 版本不支持 目前新安装的 nfs 为 v4 版本，v2 已经废弃，但是很多比较老的内核不支持 v4，可能由于 nfs 解决方法 在内核配置中打开 nfs 文件系统对 nfs v4 的支持： \u003c*\u003e NFS client support for NFS version 4 在 nfs server 端的配置中打开对 nfs v2、nfs v3 和 nfs v4 的支持 $ echo 'RPCNFSDOPTS=\"--nfs-version 2,3,4 --debug --syslog\"' \u003e\u003e /etc/default/nfs-kernel-server $ systmectl restart nfs-server.service ","date":"2023-06-19","objectID":"/posts/embedeedevr/petalinux/petalinux_2/:1:4","tags":["Petalinux","ZYNQ","NFS"],"title":"Petalinux(二)：远程启动","uri":"/posts/embedeedevr/petalinux/petalinux_2/"},{"categories":["Embedded EVR"],"content":" 课题需要可能要在 ZYNQ 上多次部署 Linux 并测试，普通的脚本安装方式太过繁琐，Xilinx 的 Petalinux 工具简化了很多流程。这里记录了一些主要步骤，由于实验室 Vivado 版本，所以选择的 Petalinux 版本也不是最新的 ","date":"2023-06-19","objectID":"/posts/embedeedevr/petalinux/petalinux_1/:0:0","tags":["Petalinux","ZYNQ","NFS"],"title":"Petalinux(一)：安装","uri":"/posts/embedeedevr/petalinux/petalinux_1/"},{"categories":["Embedded EVR"],"content":"why petalinux? 比分步编译更便捷的配置和编译源码 优势：petalinux 读取输入硬件配置，并根据硬件来自动的配置编译 u-boot，kernel，devicetree. 缺点：软件对系统版本，依赖版本要求比较高，配置相对麻烦。如果不按照规定好的顺序执行命令会遇上较多未知 BUG 目的：简化编译的过程，缩短时间并生成与硬件对应的正确的设备树文件 ","date":"2023-06-19","objectID":"/posts/embedeedevr/petalinux/petalinux_1/:0:1","tags":["Petalinux","ZYNQ","NFS"],"title":"Petalinux(一)：安装","uri":"/posts/embedeedevr/petalinux/petalinux_1/"},{"categories":["Embedded EVR"],"content":"petalinux 的安装 petalinux 对操作系统版本和依赖版本要求很高，只能在官方文档指定的发行版安装。这里以 petalinux 2017.04 为例 OS: ubuntu16.04(docker x86-64) Dependencies: sudo dpkg --add-architecture i386 sudo apt install libssl-dev flex bison chrpath socat autoconf libtool texinfo gcc-multilib libsdl1.2-dev libglib2.0-dev screen pax net-tools wget diffstat xterm gawk xvfb git make libncurse5-dev tftpd zlib1g libssl-dev gnupg tar unzip build-essential libtool-bin dialog cpio lsb-release zlib1g:i386 zlib1g-dev:i386 locales openjdk-8-jdk sudo dpkg-reconfigure locales export LANG=en_US.UTF-8 由于 Petalinux 依赖发行版版本，推荐采用 Docker 环境安装。请查看 Petalinux 2017.04 Docker 环境 ","date":"2023-06-19","objectID":"/posts/embedeedevr/petalinux/petalinux_1/:0:2","tags":["Petalinux","ZYNQ","NFS"],"title":"Petalinux(一)：安装","uri":"/posts/embedeedevr/petalinux/petalinux_1/"},{"categories":["Embedded EVR"],"content":"petalinux 的使用 创建一个 ZYNQ 的工程模板： petalinux-create --type project --template zynq --name petalinux 读取分析硬件所使用的开发版型号来配置： petalinux-config --get-hw-description /mnt/linux_base.sdk 配置内核和根文件系统： petalinux-config -c kernel petalinux-config -c rootfs 开始编译： petalinux-build 将编译好的工程打包输出： petalinux-package --boot --fsbl ./images/linux/zynq_fsbl.elf --fpga --u-boot --force 使用 qemu 虚拟化平台对产生的 BootLoader 和 linux 内核进行测试（可选） petalinux-boot --qemu --prebuilt 3 将输出的文件移动到开发板启动，或者使用 tftp 方式远程启动： image.ub: linux 的内核镜像，并且打包了设备树文件 plnx_arm-system.dtb, 在内存中运行的文件系统 ramdisk. # image.ub images { kernel@0 { description = \"Linux Kernel\"; data = /incbin/(\"zImage\"); type = \"kernel\"; arch = \"arm\"; os = \"linux\"; compression = \"none\"; load = \u003c0x8000\u003e; entry = \u003c0x8000\u003e; hash@1 { algo = \"sha1\"; }; }; fdt@0 { description = \"Flattened Device Tree blob\"; data = /incbin/(\"plnx_arm-system.dtb\"); type = \"flat_dt\"; arch = \"arm\"; compression = \"none\"; hash@1 { algo = \"sha1\"; }; }; ramdisk@0 { description = \"ramdisk\"; data = /incbin/(\"petalinux-user-image-plnx_arm.cpio.gz\"); type = \"ramdisk\"; arch = \"arm\"; os = \"linux\"; compression = \"none\"; hash@1 { algo = \"sha1\"; }; }; }; ","date":"2023-06-19","objectID":"/posts/embedeedevr/petalinux/petalinux_1/:0:3","tags":["Petalinux","ZYNQ","NFS"],"title":"Petalinux(一)：安装","uri":"/posts/embedeedevr/petalinux/petalinux_1/"},{"categories":["Embedded EVR"],"content":"petalinux 产生设备树的分析 使用 petalinux 的优势：自动分析硬件并产生设备树，也可以添加需要的部分并手动编译。 产生设备树的目录： $(project)/components/plnx_workspace/device-tree/device-tree-generation/ 设备树主要分两个部分： ARM CPU 相关的设备包括处理器内存，系统总线等等，在 zynq-7000.dtsi 中。（dtsi:设备树中描述 SOC 级的信息，一般不需要修改；dts: 设备树的源文件，修改设备树的主要对象；dtb: 由 dts 文件编译生成的二进制文件，由内核在启动时候读取并解析） petalinux 根据硬件的配置来生成 pl.dtsi 文件，文件内包括在根节点下的 FPGA 部分的设备树。 pl.dtsi 和 zynq-7000.dtsi 包含在 system-top.dts 内，手动添加的设备树也包含在内。 plnx_arm-system.dts 是处理了包含关系后的文件，编译生成 plnx_arm-system.dtb. pl.dtsi ---------| pcw.dtsi ---------|----\u003e system-top.dts ----\u003e plnx_arm-system.dts -----(dtc)----\u003e plnx_arm-system.dtb zynq-7000.dtsi ---| ","date":"2023-06-19","objectID":"/posts/embedeedevr/petalinux/petalinux_1/:0:4","tags":["Petalinux","ZYNQ","NFS"],"title":"Petalinux(一)：安装","uri":"/posts/embedeedevr/petalinux/petalinux_1/"},{"categories":["Embedded EVR"],"content":"实验：产生 GPIO 设备树文件，使用 Linux 内的 gpio 驱动程序，用文件 IO 方式驱动 led 系统描述：PS 和 PL 各有一个 led，通过 petalinux 产生一个完整 linux 系统，FPGA 端烧写一个 GPIO 控制器，输出 1 位信号到 R19 引脚，FPGA 的 R19 引脚连接了 pl 侧的 led 灯： set_property PACKAGE_PIN R19 [get_ports {gpio_out}] # R19引脚连接板上的led灯 set_property IOSTANDARD LVCMOS33 [get_ports {gpio_out}] linux 内核包含了 gpio 的驱动，可以根据设备树信息来自动检测硬件 $ cd /sys/class/gpio \u0026\u0026 ls export gpiochip906 gpiochip504 unexport # 访问/sys/class/gpio/目录，gpio906和gpio504分别是PS端和PL端的gpio控制器, export是内核提供的文件用于导出gpio的操作接口。 $ echo 906 \u003e export $ echo 504 \u003e export # 向export文件写入GPIO编号，就可以获得这个GPIO的操作接口。 $ ls export gpio906 gpiochip906 gpio504 gpiochip504 unexport # 新产生了gpio906和gpio504目录，目录中就是操作接口。 $ cd gpio906 \u0026\u0026 ls active_low direction power uevent device edge subsystem value # direction控制gpio的方向，value为gpio的输入输出值。 $ echo out \u003e direction $ echo 1 \u003e value # led灯灭 $ echo 0 \u003e value # led灯亮 # 通过一般的IO操作value这个文件就可以控制灯的亮灭。 产生的 GPIO 设备树部分(FPGA 侧): axi_gpio_0: gpio@41200000 { #gpio-cells = \u003c2\u003e; compatible = \"xlnx,xps-gpio-1.00.a\"; gpio-controller ; reg = \u003c0x41200000 0x10000\u003e; xlnx,all-inputs = \u003c0x0\u003e; xlnx,all-inputs-2 = \u003c0x0\u003e; xlnx,all-outputs = \u003c0x1\u003e; xlnx,all-outputs-2 = \u003c0x0\u003e; xlnx,dout-default = \u003c0x00000000\u003e; xlnx,dout-default-2 = \u003c0x00000000\u003e; xlnx,gpio-width = \u003c0x1\u003e; xlnx,gpio2-width = \u003c0x20\u003e; xlnx,interrupt-present = \u003c0x0\u003e; xlnx,is-dual = \u003c0x0\u003e; xlnx,tri-default = \u003c0xFFFFFFFF\u003e; xlnx,tri-default-2 = \u003c0xFFFFFFFF\u003e; }; ","date":"2023-06-19","objectID":"/posts/embedeedevr/petalinux/petalinux_1/:0:5","tags":["Petalinux","ZYNQ","NFS"],"title":"Petalinux(一)：安装","uri":"/posts/embedeedevr/petalinux/petalinux_1/"},{"categories":["Embedded EVR"],"content":"实验：直接将 FPGA 寄存器信号输出到 R19 引脚，通过 AXI-Lite 总线读写寄存器来控制 led 定义一个 32-bits 寄存器来接受总线信号，写入寄存器的值取一位输出到 led 灯 # 定义一个32位寄存器 reg [C_S_AXI_DATA_WIDTH-1:0] slv_reg0; # 将寄存器的第0位连接到输出信号 assign test_out = slv_reg0[0]; # 将总线模块打包，在test中调用AXI总线，添加一个输出信号test_out myip_v1_0_S00_AXI # ( .C_S_AXI_DATA_WIDTH(C_S00_AXI_DATA_WIDTH), .C_S_AXI_ADDR_WIDTH(C_S00_AXI_ADDR_WIDTH) ) myip_v1_0_S00_AXI_inst ( .S_AXI_ACLK(s00_axi_aclk), .S_AXI_ARESETN(s00_axi_aresetn), .S_AXI_AWADDR(s00_axi_awaddr), .S_AXI_AWPROT(s00_axi_awprot), .S_AXI_AWVALID(s00_axi_awvalid), .S_AXI_AWREADY(s00_axi_awready), .S_AXI_WDATA(s00_axi_wdata), .S_AXI_WSTRB(s00_axi_wstrb), .S_AXI_WVALID(s00_axi_wvalid), .S_AXI_WREADY(s00_axi_wready), .S_AXI_BRESP(s00_axi_bresp), .S_AXI_BVALID(s00_axi_bvalid), .S_AXI_BREADY(s00_axi_bready), .S_AXI_ARADDR(s00_axi_araddr), .S_AXI_ARPROT(s00_axi_arprot), .S_AXI_ARVALID(s00_axi_arvalid), .S_AXI_ARREADY(s00_axi_arready), .S_AXI_RDATA(s00_axi_rdata), .S_AXI_RRESP(s00_axi_rresp), .S_AXI_RVALID(s00_axi_rvalid), .S_AXI_RREADY(s00_axi_rready), .test_out(test_out) ); # 修改wrapper添加输出信号 output wire test_out # 绑定输出信号到led灯相连的引脚 set_property PACKAGE_PIN R19 [get_ports {test_out}] set_property IOSTANDARD LVCMOS33 [get_ports {test_out}] petalinux 根据系统硬件设计添加了 AXI-Lite 总线对应的设备树部分 # amba-axi总线的设备树部分 / { amba_pl: amba_pl { #address-cells = \u003c1\u003e; #size-cells = \u003c1\u003e; compatible = \"simple-bus\"; ranges ; myip_v1_0_0: myip_v1_0@43c00000 { # 寄存器的物理地址是0x43c00000 compatible = \"xlnx,myip-v1-0-1.0\"; reg = \u003c0x43c00000 0x10000\u003e; xlnx,s00-axi-addr-width = \u003c0x4\u003e; xlnx,s00-axi-data-width = \u003c0x20\u003e; }; }; }; 寄存器的物理地址是 0x43c00000，对这个地址的第一个字节的 0 位写值就可以控制 led 灯的亮灭 $ busybox devmem 0x43c00000 8 0x01 # 灯灭 $ busybox devmem 0x43c00000 8 0x00 # 灯亮 Q: 最小的寄存器组: 4 个(0x43c00000-0x43c0000f), 从 0x40000000-0x4fffffff 全部被映射到了最初的 16 个字节。 实际上被映射的物理内存区域有 1G，从地址 0x40000000-0x4fffffff ","date":"2023-06-19","objectID":"/posts/embedeedevr/petalinux/petalinux_1/:0:6","tags":["Petalinux","ZYNQ","NFS"],"title":"Petalinux(一)：安装","uri":"/posts/embedeedevr/petalinux/petalinux_1/"},{"categories":["Embedded EVR"],"content":"测试：从 Linux 端读写寄存器，寄存器连接一个宽度 16bit，深度 256 的 Block RAM，通过读写 3 个寄存器来实现对 Block RAM 的指定地址的读写。 由一个 TOP 模块，来例化了一个 AXI-Lite 总线接口，这个总线接口定义了 60 个寄存器并且引出。还有一个 BlockRAM 模块，将 AXI 总线定义的三个寄存器输入到 RAM 的控制接口里，然后通过对总线读写来控制 RAM。 AXI 总线模块： AXI_Lite axi_lite (.register00(AXI_Lite_register00), .register01(AXI_Lite_register01), .register02(AXI_Lite_register02), .register03(AXI_Lite_register03), .register04(AXI_Lite_register04), .register05(AXI_Lite_register05), .register06(AXI_Lite_register06), .register07(AXI_Lite_register07), .register08(AXI_Lite_register08), .register09(AXI_Lite_register09), .register10(AXI_Lite_register10), ...... 对 BlockRAM 的接口定义： bram_wrapper mappingRAM ( # 写地址：0x000-0x100(深度256) .BRAM_PORTA_0_addr(AXI_Lite_register01[7:0]), # 写时钟：FCLK_CLK0 .BRAM_PORTA_0_clk(s00_axi_aclk_0_1), # 写数据：16bit数据 .BRAM_PORTA_0_din(AXI_Lite_register02[15:0]), # PORTA使能 .BRAM_PORTA_0_en(1'b1), # PORTA写使能 .BRAM_PORTA_0_we(1'b1), # PORTB读地址 .BRAM_PORTB_0_addr(AXI_Lite_register03[7:0]), # PORTB读时钟 .BRAM_PORTB_0_clk(s00_axi_aclk_0_1), # PORTB读数据 .BRAM_PORTB_0_dout(w_ramout[15:0]), # PORTB读使能 .BRAM_PORTB_0_en(1'b1) ); ramout_0 -\u003e led(R19) # register ———————————————————— ————————————- | register01[7:0] | ————\u003e 写地址，输入到PORTA addr ——————\u003e | | ———————————————————— | register02[15:0] | ————\u003e 写数据，输入到PORTA din ——————\u003e | 256 x 16 | ———————————————————— | register03[7:0] | ————\u003e 读地址，输入到PORTB addr ——————\u003e | | ———————————————————— ————————————- | ramout[0] —————————————— | led \u003c———————————————————| ramout[15:0] |————————— —————————————— 测试过程: # 初始状态：ram内全部清零，ramout[0] 输出为0，\"led灯亮\" # 给RAM的写地址端口写入0x43c00004 $ busybox devmem 0x43c00004 8 0x55 # 给RAM的写数据端口写入16位数据0x0001 $ busybox devmem 0x43c00008 16 0x0001 此时RAM的0x55地址写入了数据 0000 0000 0000 0001 # 给0x43c0000c地址写入0x55，表示给RAM的读地址端口写0x55 $ busybox devmem 0x43c0000c 8 0x55 此时ramout的第0位由0变成了1，\"led灯灭\" # 把0x55的数据重新写为0 $ busybox devmem 0x43c00008 16 0x0000 \"led灯亮\" # 或者改变读地址的值 $ busybox devmem 0x43c0000c 8 0x56 \"led灯亮\" 上述实验证明数据写入 RAM 成功 ","date":"2023-06-19","objectID":"/posts/embedeedevr/petalinux/petalinux_1/:0:7","tags":["Petalinux","ZYNQ","NFS"],"title":"Petalinux(一)：安装","uri":"/posts/embedeedevr/petalinux/petalinux_1/"},{"categories":["Linux"],"content":"前言 安装 Gentoo 并不复杂，很多人混淆了复杂和耗时。在安装的过程中，大部分的时间都在做别的事情。同时，Gentoo 的安装步骤是清晰的，Handbook 和各路神仙的总结实际上已经很全面了。因此，没有必要再做重复的劳动，一些个性化的关键点记录就足够了。 为了使系统保持 Suckless，尽量避免用不到的功能，我还是继续沿用裸 wm 的方式。简而言之：gentoo + openrc + i3wm + polybar + nvim。我的目标是尽量在一天内完成系统的整体安装，再用一周时间进行小修小补。而在流程化的步骤下，一天内的实际安装时间在 1 小时左右，而其余时间都在做其他事情。 此外，对于小新 Pro 这种散热垃圾的 Laptop，一个带风扇的散热架是必要的。否则，emerge -e @world 是真的会卡死（哭）。 ","date":"2023-06-18","objectID":"/posts/linux/gentoo/gentoo/:0:1","tags":["Linux","Gentoo"],"title":"Gentoo 安装小记","uri":"/posts/linux/gentoo/gentoo/"},{"categories":["Linux"],"content":"安装步骤 Gentoo 的安装大体上是规范的，但是针对不同用户的需求和理念，也有不一样的方式。或多或少的，存在一些坑 我在安装过程主要参考的几个链接： 官方 Handbook，这是最权威的手册，当问题不确定时，以 Handbook 为准 Handbook 一篇较为详细的安装笔记，属于经验丰富的老玩家心得了，很有参考价值 Gentoo 安装流程分享(step by step)，第一篇之基本系统的安装 OriPoin’s blog，详细介绍了 Gentoo 的优化方式，但是没必要采用 O3，会带来很多未知问题 Emerge your world the lean way Optimize Your system the stupid way bitbili’s blog，非常非常详细的介绍了 Gentoo 的安装和使用 Gentoo Linux 安装及使用指南 Yangmame 的博客（比较早期） Gentoo 安装教程 ayamir 的知乎记录（参考了 2 和 5） 2020-Gentoo 双系统安装指北 GTrush 的博客 新手 Gentoo 折腾记录 1 Jioushan 的博客 不完整的 Gentoo 安装 Google，Stack Overflow，gentoo wiki，arch wiki 等 ","date":"2023-06-18","objectID":"/posts/linux/gentoo/gentoo/:0:2","tags":["Linux","Gentoo"],"title":"Gentoo 安装小记","uri":"/posts/linux/gentoo/gentoo/"},{"categories":["Linux"],"content":"make.conf make.conf 可以说是 Gentoo 的核心了，针对 PC 的配置、优化以及对系统的预期基本上都是在这个文件中定义的，首先列出我的： # These settings were set by the catalyst build script that automatically # built this stage. # Please consult /usr/share/portage/config/make.conf.example for a more # detailed example. COMMON_FLAGS=\"-march=native -O2 -pipe\" CFLAGS=\"${COMMON_FLAGS}\" CXXFLAGS=\"${COMMON_FLAGS}\" FCFLAGS=\"${COMMON_FLAGS}\" FFLAGS=\"${COMMON_FLAGS}\" USE=\"X elogind mount cjk i3wm mpd network pulseaudio ipc opengl dbus -gnome -kde\" MAKEOPTS=\"-j6\" LC_MESSAGES=C EMERGE_DEFAULT_OPTS=\"--ask --verbose --load-average --newuse --with-bdeps=y --keep-going --deep\" CPU_FLAGS_X86=\"aes avx avx2 f16c fma3 mmx mmxext pclmul popcnt rdrand sse sse2 sse3 sse4_1 sse4_2 ssse3\" AUTO_CLEAN=\"yes\" PORTDIR=\"/var/db/repos/gentoo\" DISTDIR=\"/var/cache/distfiles\" PKGDIR=\"/var/chache/binpkgs\" PORTAGE_TMPDIR=\"/tmp\" PORTAGE_COMPRESS=\"zstd\" BINPKG_COMPRESS=\"zstd\" ACCEPT_LICENSE=\"*\" ACCEPT_KEYWORDS=\"~amd64\" GRUB_PLATFORMS=\"efi-64\" VIDEO_CARDS=\"nouveau\" GENTOO_MIRRORS=\"https://mirrors.tuna.tsinghua.edu.cn/gentoo\" MICROCODE_SIGNATURES=\"-S\" # NOTE: This stage was built with the bindist Use flag enabled # This sets the language of build output to English. # Please keep this setting intact when reporting bugs. LC_MESSAGES=C.utf8 # ccache FEATURES=\"ccache -test\" CCACHE_DIR=\"/var/cache/ccache\" # aria2 FETCHCOMMAND=\"/usr/bin/aria2c -d \\${DISTDIR} -o \\${FILE} --allow-overwrite=true --max-tries=5 --max-file-not-found=2 --max-concurrent-downloads=5 --connect-timeout=5 --timeout=5 --split=5 --min-split-size=2M --lowest-speed-limit=20K --max-connection-per-server=9 --uri-selector=feedback \\${URI}\" RESUMECOMMAND=\"${FETCHCOMMAND}\" ","date":"2023-06-18","objectID":"/posts/linux/gentoo/gentoo/:0:3","tags":["Linux","Gentoo"],"title":"Gentoo 安装小记","uri":"/posts/linux/gentoo/gentoo/"},{"categories":["Linux"],"content":"问题列举 安装 Gentoo 是相对容易的，但是往往会遇上很多奇怪的问题。比如常见的循环依赖，某个程序编译失败… 这种时候首先应该去 Gentoo Package 查找对应包是否有 Bug 记录，以及解决方法 这里主要列举的是我在安装过程中遇到的问题，以及解决方法 复杂密码换简单密码 Gentoo 默认是复杂密码，为了便于日常使用，改为简单密码： /etc/security/passwdqc.conf min=8,8,8,8,8 max=40 passphrase=0 match=4 similar=permit random=24 enforce=none retry=3 或者全局 USE -pam，我还没有尝试 eudev 还是 systemd-utils？ Gentoo 目前用 systemd-utils 替代了原本的 eudev，所以解决办法有： 使用 systemd-utils 管理设备，不要再安装 eudev，这是最简单的。官方的原话是：in general, you should not worry about installing anything *udev manually by yourself and you should imho not have anything like that in your world file. 如果你痛恨和 systemd 有关的一切，可以为 systemd-utils 包-udev USE，然后应该就可以安装 eudev 了。需要注意的是，eudev 不应该被加入到 world file 中。此外还有一些其他的 USE 也会影响，总之这很麻烦。建议还是不要折腾了，systemd-utils 只是从 systemd 中分离出来的组件而已，它包含了 udev Desktop profiles？ Desktop profiles 预设了很多 USE，并包含了一些 system 依赖。对于 KDE 和 GNOME 用户，Desktop profiles 中提供的增量可以省很多事。但是对于裸 WM 来说，没有必要为使用 Desktop，默认的 profiles 或者 systemd profiles 就可以了。在最小化的基础上，安装软件时检查 USE 并逐步添加自己的全局 USE /tmp 挂载 有时候 fstab 中会忘记挂载/tmp，这样/tmp 目录在磁盘中，在 portage 运行时主要以/tmp 作为暂存目录，可能会反复读写 SSD 降低寿命。将/tmp 挂载到内存中，毕竟内存更加皮实耐用 # size 的大小一般为内存大小的一半 tmpfs /tmp tmpfs rw,nosuid,noatime,nodev,size=16G,mode=1777 0 0 循环依赖问题 是在安装 polybar 的时候遇到了这个问题，其他人反应 vim 也有这个循环依赖。貌似不是个别人遇到的问题 循环依赖问题：循环依赖可以是多个，比如：A 依赖 B，B 依赖 C，而 C 又依赖 A。而在此过程中，A 的 USE 会对 B 造成影响，而 B 又对 C 造成影响，这种影响可以是+或者- USE。但是 C 又依赖了 A，与 A 的新 USE 冲突 如下报错信息: * Error: circular dependencies: ​ (media-libs/libsndfile-1.2.0:0/0::gentoo, ebuild scheduled for merge) depends on (media-sound/mpg123-1.31.3:0/0::gentoo, ebuild scheduled for merge) (buildtime_slot_op) (media-sound/pulseaudio-16.1:0/0::gentoo, ebuild scheduled for merge) (buildtime) (media-libs/libpulse-16.1-r2:0/0::gentoo, ebuild scheduled for merge) (buildtime) (media-libs/libsndfile-1.2.0:0/0::gentoo, ebuild scheduled for merge) (buildtime) ​ It might be possible to break this cycle by applying any of the following changes: - media-libs/libsndfile-1.2.0 (Change USE: +minimal) - media-sound/mpg123-1.31.3 (Change USE: -pulseaudio) ​ Note that this change can be reverted, once the package has been installed. ​ Note that the dependency graph contains a lot of cycles. Several changes might be required to resolve all cycles. Temporarily changing some use flag for all packages might be the better option. 解决方法： # 首先打破循环依赖，-1(oneshot) 避免把包写入 world 文件 USE=\"-pulseaudio\" emerge -1 media-sound/mpg123 # 安装 polybar，Global USE 定义了 pulseaudio emerge polybar # 成功安装后，再恢复以前的状态 USE=\"pulseaudio\" emerge -1 media-sound/mpg123 由于日常维护和debug太耗时，目前已放弃 Gentoo，此文章结束 ","date":"2023-06-18","objectID":"/posts/linux/gentoo/gentoo/:0:4","tags":["Linux","Gentoo"],"title":"Gentoo 安装小记","uri":"/posts/linux/gentoo/gentoo/"},{"categories":null,"content":"个人经历 本科毕业于北京邮电大学自动化学院，博士毕业于中国科学院高能物理研究所，研究方向为粒子加速器控制技术和加速器定时系统 目前在浪潮信息从事服务器 BIOS 和 BMC 的相关研究，欢迎交流沟通：gitzhangzhao@gmail.com ","date":"0001-01-01","objectID":"/about/:0:1","tags":null,"title":"","uri":"/about/"},{"categories":null,"content":"研究兴趣 Embedded system FPGA ZYNQ Kernel EPICS RISC V BIOS UEFI BMC RTOS ","date":"0001-01-01","objectID":"/about/:0:2","tags":null,"title":"","uri":"/about/"}]